Перем ПравилаВыгрузкиТипов;
Перем ПравилаЗагрузкиТипов;

#Область ПреобразованияОбъектовСлужебные

// Возвращает структуру, содержащую информацию
// о переданном виде объектов метаданных
//
// Параметры:
//  Имя					- Строка		- Имя вида объектов метаданных (например, константа,
//										  ПланСчетов и т.п.), может передаваться в ед. мн. числе
//  ТекИБ				- COMОбъект,	- Информационная база, из которой будет получена информация
//										  о виде объектов, Неопределено - текущая инф. база
//
// Возвращаемое значение:
//   Структура			- Содержимое:
//							Коллекция		- Менеджер вида объектов (например, СправочникиМенеджер)
//							МетаКоллекция	- Коллекция метаданных вида объектов (например, Справочники)
//							Имя				- Имя вида объектов (например, "ПланСчетов")
//							ИмяКоллекции	- Имя коллекции вида объектов (например,  "ПланыСчетов")
//							Представление	- Представление вида объектов (например, "План счетов")
//							ПредставлениеМ	- Представление коллекции вида объектов (например,  "Планы счетов")
//							ИмяТипа			- Имя типа (конкретный элемент, например, Контрагенты)
//							Картинка		- Картинка коллекции по умолчанию 
//							КартинкаОбъекта - Картинка объекта коллекции по умолчанию 
//							Конструктор		- Имя функции конструктора экземпляра объекта (например: СоздатьЭлемент)
//							КонструкторАльт - Имя альтернативной функции конструктора экземпляра объекта (например: СоздатьГруппу) 
//
Функция ПолучитьОписаниеВидаОбъектов(Имя, ТекИБ = Неопределено) Экспорт
	
	ВремСтруктураВида = Новый Структура("Коллекция,
										|МетаКоллекция,
										|Имя,
										|ИмяКоллекции,
										|Представление,
										|ПредставлениеМ,
										|ИмяТипа,
										|Картинка,
										|КартинкаОбъекта,
										|Конструктор,
										|КонструкторАльт");
	
	Если ТипЗнч(Имя) = Тип("Тип") Тогда
		МетаданныеТипа = Метаданные.НайтиПоТипу(Имя);
		ИмяТипа = МетаданныеТипа.ПолноеИмя();
		ПозТчк = Найти(ИмяТипа, ".");
		НИмя = НРег(Лев(ИмяТипа, ПозТчк - 1));
		ВремСтруктураВида.ИмяТипа = НРег(Сред(ИмяТипа, ПозТчк + 1));
	ИначеЕсли ТипЗнч(Имя) = Тип("Строка") Тогда
		Если Найти(Имя, ".") > 0 Тогда
			ПозТчк = Найти(Имя, ".");
			НИмя = НРег(Лев(Имя, ПозТчк - 1));
			ВремСтруктураВида.ИмяТипа = НРег(Сред(Имя, ПозТчк + 1));
		Иначе
			НИмя = НРег(СтрЗаменить(СтрЗаменить(Имя, "-", ""), " ", ""));
			ВремСтруктураВида.ИмяТипа = "";
		КонецЕсли;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Если НИмя = "константы" ИЛИ НИмя = "константа" Тогда
		ВремСтруктураВида.Коллекция		= ?(ТекИБ = Неопределено, Константы, ТекИБ.Константы);
		ВремСтруктураВида.МетаКоллекция	= ?(ТекИБ = Неопределено, Метаданные.Константы, ТекИБ.Метаданные.Константы);
		ВремСтруктураВида.Имя			= "Константа";
		ВремСтруктураВида.ИмяКоллекции	= "Константы";
		ВремСтруктураВида.Представление	= "Константа";
		ВремСтруктураВида.ПредставлениеМ= "Константы";
		ВремСтруктураВида.Конструктор		= Неопределено;
		ВремСтруктураВида.КонструкторАльт	= Неопределено;
		#Если Клиент Тогда
		ВремСтруктураВида.Картинка		= БиблиотекаКартинок.Константа;
		ВремСтруктураВида.КартинкаОбъекта	= БиблиотекаКартинок.Константа;
		#КонецЕсли
	ИначеЕсли НИмя = "справочники" ИЛИ НИмя = "справочник" Тогда
		ВремСтруктураВида.Коллекция		= ?(ТекИБ = Неопределено, Справочники, ТекИБ.Справочники);
		ВремСтруктураВида.МетаКоллекция	= ?(ТекИБ = Неопределено, Метаданные.Справочники, ТекИБ.Метаданные.Справочники);
		ВремСтруктураВида.Имя			= "Справочник";
		ВремСтруктураВида.ИмяКоллекции	= "Справочники";
		ВремСтруктураВида.Представление	= "Справочник";
		ВремСтруктураВида.ПредставлениеМ= "Справочники";
		ВремСтруктураВида.Конструктор		= "СоздатьЭлемент";
		ВремСтруктураВида.КонструкторАльт	= "СоздатьГруппу";
		#Если Клиент Тогда
		ВремСтруктураВида.Картинка		= БиблиотекаКартинок.Справочник;
		ВремСтруктураВида.КартинкаОбъекта	= БиблиотекаКартинок.СправочникОбъект;
		#КонецЕсли
	ИначеЕсли НИмя = "документы" ИЛИ НИмя = "документ" Тогда
		ВремСтруктураВида.Коллекция		= ?(ТекИБ = Неопределено, Документы, ТекИБ.Документы);
		ВремСтруктураВида.МетаКоллекция	= ?(ТекИБ = Неопределено, Метаданные.Документы, ТекИБ.Метаданные.Документы);
		ВремСтруктураВида.Имя			= "Документ";
		ВремСтруктураВида.ИмяКоллекции	= "Документы";
		ВремСтруктураВида.Представление	= "Документ";
		ВремСтруктураВида.ПредставлениеМ= "Документы";
		ВремСтруктураВида.Конструктор		= "СоздатьДокумент";
		ВремСтруктураВида.КонструкторАльт	= Неопределено;
		#Если Клиент Тогда
		ВремСтруктураВида.Картинка		= БиблиотекаКартинок.Документ;
		ВремСтруктураВида.КартинкаОбъекта	= БиблиотекаКартинок.ДокументОбъект;
		#КонецЕсли
	ИначеЕсли НИмя = "журналыдокументов" ИЛИ НИмя = "журналдокументов" Тогда
		ВремСтруктураВида.Коллекция		= ?(ТекИБ = Неопределено, ЖурналыДокументов, ТекИБ.ЖурналыДокументов);
		ВремСтруктураВида.МетаКоллекция	= ?(ТекИБ = Неопределено, Метаданные.ЖурналыДокументов, ТекИБ.Метаданные.ЖурналыДокументов);
		ВремСтруктураВида.Имя			= "ЖурналДокументов";
		ВремСтруктураВида.ИмяКоллекции	= "ЖурналыДокументов";
		ВремСтруктураВида.Представление	= "Журнал документов";
		ВремСтруктураВида.ПредставлениеМ= "Журналы документов";
		ВремСтруктураВида.Конструктор		= Неопределено;
		ВремСтруктураВида.КонструкторАльт	= Неопределено;
		#Если Клиент Тогда
		ВремСтруктураВида.Картинка		= БиблиотекаКартинок.ЖурналДокументов;
		ВремСтруктураВида.КартинкаОбъекта	= БиблиотекаКартинок.ЖурналДокументов;
		#КонецЕсли
	ИначеЕсли НИмя = "планывидовхарактеристик" ИЛИ НИмя = "планвидовхарактеристик" Тогда
		ВремСтруктураВида.Коллекция		= ?(ТекИБ = Неопределено, ПланыВидовХарактеристик, ТекИБ.ПланыВидовХарактеристик);
		ВремСтруктураВида.МетаКоллекция	= ?(ТекИБ = Неопределено, Метаданные.ПланыВидовХарактеристик, ТекИБ.Метаданные.ПланыВидовХарактеристик);
		ВремСтруктураВида.Имя			= "ПланВидовХарактеристик";
		ВремСтруктураВида.ИмяКоллекции	= "ПланыВидовХарактеристик";
		ВремСтруктураВида.Представление	= "План видов характеристик";
		ВремСтруктураВида.ПредставлениеМ= "Планы видов характеристик";
		ВремСтруктураВида.Конструктор		= "СоздатьЭлемент";
		ВремСтруктураВида.КонструкторАльт	= "СоздатьГруппу";
		#Если Клиент Тогда
		ВремСтруктураВида.Картинка		= БиблиотекаКартинок.ПланВидовХарактеристик;
		ВремСтруктураВида.КартинкаОбъекта	= БиблиотекаКартинок.ПланВидовХарактеристик;
		#КонецЕсли
	ИначеЕсли НИмя = "планысчетов" ИЛИ НИмя = "плансчетов" Тогда
		ВремСтруктураВида.Коллекция		= ?(ТекИБ = Неопределено, ПланыСчетов, ТекИБ.ПланыСчетов);
		ВремСтруктураВида.МетаКоллекция	= ?(ТекИБ = Неопределено, Метаданные.ПланыСчетов, ТекИБ.Метаданные.ПланыСчетов);
		ВремСтруктураВида.Имя			= "ПланСчетов";
		ВремСтруктураВида.ИмяКоллекции	= "ПланыСчетов";
		ВремСтруктураВида.Представление	= "План счетов";
		ВремСтруктураВида.ПредставлениеМ= "Планы счетов";
		ВремСтруктураВида.Конструктор		= "СоздатьСчет";
		ВремСтруктураВида.КонструкторАльт	= Неопределено;
		#Если Клиент Тогда
		ВремСтруктураВида.Картинка		= БиблиотекаКартинок.ПланСчетов;
		ВремСтруктураВида.КартинкаОбъекта	= БиблиотекаКартинок.ПланСчетов;
		#КонецЕсли
	ИначеЕсли НИмя = "планывидоврасчета" ИЛИ НИмя = "планвидоврасчета" Тогда
		ВремСтруктураВида.Коллекция		= ?(ТекИБ = Неопределено, ПланыВидовРасчета, ТекИБ.ПланыВидовРасчета);
		ВремСтруктураВида.МетаКоллекция	= ?(ТекИБ = Неопределено, Метаданные.ПланыВидовРасчета, ТекИБ.Метаданные.ПланыВидовРасчета);
		ВремСтруктураВида.Имя			= "ПланВидовРасчета";
		ВремСтруктураВида.ИмяКоллекции	= "ПланыВидовРасчета";
		ВремСтруктураВида.Представление	= "План видов расчета";
		ВремСтруктураВида.ПредставлениеМ= "Планы видов расчета";
		ВремСтруктураВида.Конструктор		= "СоздатьВидРасчета";
		ВремСтруктураВида.КонструкторАльт	= Неопределено;
		#Если Клиент Тогда
		ВремСтруктураВида.Картинка		= БиблиотекаКартинок.ПланВидовРасчета;
		ВремСтруктураВида.КартинкаОбъекта	= БиблиотекаКартинок.ПланВидовРасчета;
		#КонецЕсли
	ИначеЕсли НИмя = "перечисления" ИЛИ НИмя = "перечисление" Тогда
		ВремСтруктураВида.Коллекция		= ?(ТекИБ = Неопределено, Перечисления, ТекИБ.Перечисления);
		ВремСтруктураВида.МетаКоллекция	= ?(ТекИБ = Неопределено, Метаданные.Перечисления, ТекИБ.Метаданные.Перечисления);
		ВремСтруктураВида.Имя			= "Перечисление";
		ВремСтруктураВида.ИмяКоллекции	= "Перечисления";
		ВремСтруктураВида.Представление	= "Перечисление";
		ВремСтруктураВида.ПредставлениеМ= "Перечисления";
		ВремСтруктураВида.Конструктор		= Неопределено;
		ВремСтруктураВида.КонструкторАльт	= Неопределено;
		#Если Клиент Тогда
		ВремСтруктураВида.Картинка		= БиблиотекаКартинок.Перечисление;
		ВремСтруктураВида.КартинкаОбъекта	= БиблиотекаКартинок.Перечисление;
		#КонецЕсли
	ИначеЕсли НИмя = "регистрысведений" ИЛИ НИмя = "регистрсведений" Тогда
		ВремСтруктураВида.Коллекция		= ?(ТекИБ = Неопределено, РегистрыСведений, ТекИБ.РегистрыСведений);
		ВремСтруктураВида.МетаКоллекция	= ?(ТекИБ = Неопределено, Метаданные.РегистрыСведений, ТекИБ.Метаданные.РегистрыСведений);
		ВремСтруктураВида.Имя			= "РегистрСведений";
		ВремСтруктураВида.ИмяКоллекции	= "РегистрыСведений";
		ВремСтруктураВида.Представление	= "Регистр сведений";
		ВремСтруктураВида.ПредставлениеМ= "Регистры сведений";
		ВремСтруктураВида.Конструктор		= "СоздатьНаборЗаписей";
		ВремСтруктураВида.КонструкторАльт	= "СоздатьМенеджерЗаписи";
		#Если Клиент Тогда
		ВремСтруктураВида.Картинка		= БиблиотекаКартинок.стд_РегистрыСведений;
		ВремСтруктураВида.КартинкаОбъекта	= БиблиотекаКартинок.РегистрСведений;
		#КонецЕсли
	ИначеЕсли НИмя = "регистрынакопления" ИЛИ НИмя = "регистрнакопления" Тогда
		ВремСтруктураВида.Коллекция		= ?(ТекИБ = Неопределено, РегистрыНакопления, ТекИБ.РегистрыНакопления);
		ВремСтруктураВида.МетаКоллекция	= ?(ТекИБ = Неопределено, Метаданные.РегистрыНакопления, ТекИБ.Метаданные.РегистрыНакопления);
		ВремСтруктураВида.Имя			= "РегистрНакопления";
		ВремСтруктураВида.ИмяКоллекции	= "РегистрыНакопления";
		ВремСтруктураВида.Представление	= "Регистр накопления";
		ВремСтруктураВида.ПредставлениеМ= "Регистры накопления";
		ВремСтруктураВида.Конструктор		= "СоздатьНаборЗаписей";
		ВремСтруктураВида.КонструкторАльт	= "СоздатьМенеджерЗаписи";
		#Если Клиент Тогда
		ВремСтруктураВида.Картинка		= БиблиотекаКартинок.РегистрНакопления;
		ВремСтруктураВида.КартинкаОбъекта	= БиблиотекаКартинок.РегистрНакопления;
		#КонецЕсли
	ИначеЕсли НИмя = "регистрыбухгалтерии" ИЛИ НИмя = "регистрбухгалтерии" Тогда
		ВремСтруктураВида.Коллекция		= ?(ТекИБ = Неопределено, РегистрыБухгалтерии, ТекИБ.РегистрыБухгалтерии);
		ВремСтруктураВида.МетаКоллекция	= ?(ТекИБ = Неопределено, Метаданные.РегистрыБухгалтерии, ТекИБ.Метаданные.РегистрыБухгалтерии);
		ВремСтруктураВида.Имя			= "РегистрБухгалтерии";
		ВремСтруктураВида.ИмяКоллекции	= "РегистрыБухгалтерии";
		ВремСтруктураВида.Представление	= "Регистр бухгалтерии";
		ВремСтруктураВида.ПредставлениеМ= "Регистры бухгалтерии";
		ВремСтруктураВида.Конструктор		= "СоздатьНаборЗаписей";
		ВремСтруктураВида.КонструкторАльт	= "СоздатьМенеджерЗаписи";
		#Если Клиент Тогда
		ВремСтруктураВида.Картинка		= БиблиотекаКартинок.РегистрБухгалтерии;
		ВремСтруктураВида.КартинкаОбъекта	= БиблиотекаКартинок.РегистрБухгалтерии;
		#КонецЕсли
	ИначеЕсли НИмя = "регистрырасчета" ИЛИ НИмя = "регистррасчета" Тогда
		ВремСтруктураВида.Коллекция		= ?(ТекИБ = Неопределено, РегистрыРасчета, ТекИБ.РегистрыРасчета);
		ВремСтруктураВида.МетаКоллекция	= ?(ТекИБ = Неопределено, Метаданные.РегистрыРасчета, ТекИБ.Метаданные.РегистрыРасчета);
		ВремСтруктураВида.Имя			= "РегистрРасчета";
		ВремСтруктураВида.ИмяКоллекции	= "РегистрыРасчета";
		ВремСтруктураВида.Представление	= "Регистр расчета";
		ВремСтруктураВида.ПредставлениеМ= "Регистры расчета";
		ВремСтруктураВида.Конструктор		= "СоздатьНаборЗаписей";
		ВремСтруктураВида.КонструкторАльт	= "СоздатьМенеджерЗаписи";
		#Если Клиент Тогда
		ВремСтруктураВида.Картинка		= БиблиотекаКартинок.РегистрРасчета;
		ВремСтруктураВида.КартинкаОбъекта	= БиблиотекаКартинок.РегистрРасчета;
		#КонецЕсли
	ИначеЕсли НИмя = "отчеты" ИЛИ НИмя = "отчет" Тогда
		ВремСтруктураВида.Коллекция		= ?(ТекИБ = Неопределено, Отчеты, ТекИБ.Отчеты);
		ВремСтруктураВида.МетаКоллекция	= ?(ТекИБ = Неопределено, Метаданные.Отчеты, ТекИБ.Метаданные.Отчеты);
		ВремСтруктураВида.Имя			= "Отчет";
		ВремСтруктураВида.ИмяКоллекции	= "Отчеты";
		ВремСтруктураВида.Представление	= "Отчет";
		ВремСтруктураВида.ПредставлениеМ= "Отчеты";
		ВремСтруктураВида.Конструктор		= "Создать";
		ВремСтруктураВида.КонструкторАльт	= Неопределено;
		#Если Клиент Тогда
		ВремСтруктураВида.Картинка		= БиблиотекаКартинок.Отчет;
		ВремСтруктураВида.КартинкаОбъекта	= БиблиотекаКартинок.Отчет;
		#КонецЕсли
	ИначеЕсли НИмя = "обработки" ИЛИ НИмя = "обработка" Тогда
		ВремСтруктураВида.Коллекция		= ?(ТекИБ = Неопределено, Обработки, ТекИБ.Обработки);
		ВремСтруктураВида.МетаКоллекция	= ?(ТекИБ = Неопределено, Метаданные.Обработки, ТекИБ.Метаданные.Обработки);
		ВремСтруктураВида.Имя			= "Обработка";
		ВремСтруктураВида.ИмяКоллекции	= "Обработки";
		ВремСтруктураВида.Представление	= "Обработка";
		ВремСтруктураВида.ПредставлениеМ= "Обработки";
		ВремСтруктураВида.Конструктор		= "Создать";
		ВремСтруктураВида.КонструкторАльт	= Неопределено;
		#Если Клиент Тогда
		ВремСтруктураВида.Картинка		= БиблиотекаКартинок.Обработка;
		ВремСтруктураВида.КартинкаОбъекта	= БиблиотекаКартинок.Обработка;
		#КонецЕсли
	ИначеЕсли НИмя = "бизнеспроцессы" ИЛИ НИмя = "бизнеспроцесс" Тогда
		ВремСтруктураВида.Коллекция		= ?(ТекИБ = Неопределено, БизнесПроцессы, ТекИБ.БизнесПроцессы);
		ВремСтруктураВида.МетаКоллекция	= ?(ТекИБ = Неопределено, Метаданные.БизнесПроцессы, ТекИБ.Метаданные.БизнесПроцессы);
		ВремСтруктураВида.Имя			= "БизнесПроцесс";
		ВремСтруктураВида.ИмяКоллекции	= "БизнесПроцессы";
		ВремСтруктураВида.Представление	= "Бизнес-процесс";
		ВремСтруктураВида.ПредставлениеМ= "Бизнес-процессы";
		ВремСтруктураВида.Конструктор		= "СоздатьБизнесПроцесс";
		ВремСтруктураВида.КонструкторАльт	= Неопределено;
		#Если Клиент Тогда
		ВремСтруктураВида.Картинка		= БиблиотекаКартинок.БизнесПроцесс;
		ВремСтруктураВида.КартинкаОбъекта	= БиблиотекаКартинок.БизнесПроцессОбъект;
		#КонецЕсли
	ИначеЕсли НИмя = "задачи" ИЛИ НИмя = "задача" Тогда
		ВремСтруктураВида.Коллекция		= ?(ТекИБ = Неопределено, Задачи, ТекИБ.Задачи);
		ВремСтруктураВида.МетаКоллекция	= ?(ТекИБ = Неопределено, Метаданные.Задачи, ТекИБ.Метаданные.Задачи);
		ВремСтруктураВида.Имя			= "Задача";
		ВремСтруктураВида.ИмяКоллекции	= "Задачи";
		ВремСтруктураВида.Представление	= "Задача";
		ВремСтруктураВида.ПредставлениеМ= "Задачи";
		ВремСтруктураВида.Конструктор		= "СоздатьЗадачу";
		ВремСтруктураВида.КонструкторАльт	= Неопределено;
		#Если Клиент Тогда
		ВремСтруктураВида.Картинка		= БиблиотекаКартинок.Задача;
		ВремСтруктураВида.КартинкаОбъекта	= БиблиотекаКартинок.ЗадачаОбъект;
		#КонецЕсли
	ИначеЕсли НИмя = "планыобмена" ИЛИ НИмя = "планобмена" Тогда
		ВремСтруктураВида.Коллекция		= ?(ТекИБ = Неопределено, ПланыОбмена, ТекИБ.ПланыОбмена);
		ВремСтруктураВида.МетаКоллекция	= ?(ТекИБ = Неопределено, Метаданные.ПланыОбмена, ТекИБ.Метаданные.ПланыОбмена);
		ВремСтруктураВида.Имя			= "ПланОбмена";
		ВремСтруктураВида.ИмяКоллекции	= "ПланыОбмена";
		ВремСтруктураВида.Представление	= "План обмена";
		ВремСтруктураВида.ПредставлениеМ= "Планы обмена";
		ВремСтруктураВида.Конструктор		= "СоздатьУзел";
		ВремСтруктураВида.КонструкторАльт	= Неопределено;
		#Если Клиент Тогда
		ВремСтруктураВида.Картинка		= БиблиотекаКартинок.ПланОбмена;
		ВремСтруктураВида.КартинкаОбъекта	= БиблиотекаКартинок.ПланОбмена;
		#КонецЕсли
	ИначеЕсли НИмя = "общиеформы" ИЛИ НИмя = "общаяформа" Тогда
		ВремСтруктураВида.Коллекция		= Неопределено;
		ВремСтруктураВида.МетаКоллекция	= ?(ТекИБ = Неопределено, Метаданные.ОбщиеФормы, ТекИБ.Метаданные.ОбщиеФормы);
		ВремСтруктураВида.Имя			= "ОбщаяФорма";
		ВремСтруктураВида.ИмяКоллекции	= "ОбщиеФормы";
		ВремСтруктураВида.Представление	= "Общая форма";
		ВремСтруктураВида.ПредставлениеМ= "Общие формы";
		ВремСтруктураВида.Конструктор		= Неопределено;
		ВремСтруктураВида.КонструкторАльт	= Неопределено;
		#Если Клиент Тогда
		ВремСтруктураВида.Картинка		= БиблиотекаКартинок.РедактироватьВДиалоге;
		ВремСтруктураВида.КартинкаОбъекта	= БиблиотекаКартинок.РедактироватьВДиалоге;
		#КонецЕсли
	ИначеЕсли НИмя = "регламентныезадания" ИЛИ НИмя = "регламентноезадание" Тогда
		ВремСтруктураВида.Коллекция		= ?(ТекИБ = Неопределено, РегламентныеЗадания, ТекИБ.РегламентныеЗадания);
		ВремСтруктураВида.МетаКоллекция	= ?(ТекИБ = Неопределено, Метаданные.РегламентныеЗадания, ТекИБ.Метаданные.РегламентныеЗадания);
		ВремСтруктураВида.Имя			= "РегламентноеЗадание";
		ВремСтруктураВида.ИмяКоллекции	= "РегламентныеЗадания";
		ВремСтруктураВида.Представление	= "Регламентное задание";
		ВремСтруктураВида.ПредставлениеМ= "Регламентные задания";
		ВремСтруктураВида.Конструктор		= "СоздатьРегламентноеЗадание()";
		ВремСтруктураВида.КонструкторАльт	= Неопределено;
		#Если Клиент Тогда
		ВремСтруктураВида.Картинка		= БиблиотекаКартинок.РегламентныеЗадания;
		ВремСтруктураВида.КартинкаОбъекта	= БиблиотекаКартинок.РегламентноеЗадание;
		#КонецЕсли
	ИначеЕсли НИмя = "роли" ИЛИ НИмя = "роль" Тогда
		ВремСтруктураВида.Коллекция		= Неопределено;
		ВремСтруктураВида.МетаКоллекция	= ?(ТекИБ = Неопределено, Метаданные.Роли, ТекИБ.Метаданные.Роли);
		ВремСтруктураВида.Имя			= "Роль";
		ВремСтруктураВида.ИмяКоллекции	= "Роли";
		ВремСтруктураВида.Представление	= "Роль";
		ВремСтруктураВида.ПредставлениеМ= "Роли";
		ВремСтруктураВида.Конструктор		= Неопределено;
		ВремСтруктураВида.КонструкторАльт	= Неопределено;
		#Если Клиент Тогда
		ВремСтруктураВида.Картинка		= БиблиотекаКартинок.ПользовательБезНеобходимыхСвойств;
		ВремСтруктураВида.КартинкаОбъекта	= БиблиотекаКартинок.ПользовательБезНеобходимыхСвойств;
		#КонецЕсли
	ИначеЕсли НИмя = "интерфейсы" ИЛИ НИмя = "интерфейс" Тогда
		ВремСтруктураВида.Коллекция		= Неопределено;
		ВремСтруктураВида.МетаКоллекция	= ?(ТекИБ = Неопределено, Метаданные.Интерфейсы, ТекИБ.Метаданные.Интерфейсы);
		ВремСтруктураВида.Имя			= "Интерфейс";
		ВремСтруктураВида.ИмяКоллекции	= "Интерфейсы";
		ВремСтруктураВида.Представление	= "Интерфейс";
		ВремСтруктураВида.ПредставлениеМ= "Интерфейсы";
		ВремСтруктураВида.Конструктор		= Неопределено;
		ВремСтруктураВида.КонструкторАльт	= Неопределено;
		#Если Клиент Тогда
		ВремСтруктураВида.Картинка		= БиблиотекаКартинок.НастройкаСписка;
		ВремСтруктураВида.КартинкаОбъекта	= БиблиотекаКартинок.НастройкаСписка;
		#КонецЕсли
	КонецЕсли;
	
	Возврат ВремСтруктураВида;
	
КонецФункции //ПолучитьОписаниеВидаОбъектов()

// Возвращает имя пердопределенных данных для переданного значения
// требуется, т.к. в разных версиях различается способ получения имени предопределенных данных
//
// Параметры:
//  Значение			- ЛюбаяСсылка	- Имя значение ссылочного типа (СправочникСсылка, ПеречислениеСсылка и т.п.)
//
// Возвращаемое значение:
//   Строка				- Имя предопределенных данных, если значение не является предопределенным, возвращается пустая строка
//
Функция ПолучитьИмяПредопределенныхДанных(Значение) Экспорт
	
	ИмяПредопределенныхДанных = "";
	
	МетаданныеЗначения = Значение.Метаданные();
	
	Текст83 = "Если Метаданные.Справочники.Содержит(МетаданныеЗначения)
			  | ИЛИ Метаданные.ПланыВидовХарактеристик.Содержит(МетаданныеЗначения)
			  | ИЛИ Метаданные.ПланыСчетов.Содержит(МетаданныеЗначения)
			  | ИЛИ Метаданные.ПланыВидовРасчета.Содержит(МетаданныеЗначения) Тогда
			  |    Если Значение.Предопределенный Тогда
			  |        ИмяПредопределенныхДанных = Значение.ИмяПредопределенныхДанных;
			  |    КонецЕсли;
			  | ИначеЕсли Метаданные.ПланыОбмена.Содержит(МетаданныеЗначения) Тогда
			  |    Если Значение.ЭтотУзел Тогда
			  |        ИмяПредопределенныхДанных = ""ЭтотУзел"";
			  |    КонецЕсли;
			  |КонецЕсли;";
	
	Текст82 = "Если Значение.Предопределенный Тогда
			  |    Если Метаданные.Справочники.Содержит(МетаданныеЗначения) Тогда
			  |        ИмяПредопределенныхДанных = Справочники[МетаданныеЗначения.Имя].ПолучитьИмяПредопределенного(Значение);
			  |    ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(МетаданныеЗначения) Тогда
			  |        ИмяПредопределенныхДанных = ПланыВидовХарактеристик[МетаданныеЗначения.Имя].ПолучитьИмяПредопределенного(Значение);
			  |    ИначеЕсли Метаданные.ПланыСчетов.Содержит(МетаданныеЗначения) Тогда
			  |        ИмяПредопределенныхДанных = ПланыСчетов[МетаданныеЗначения.Имя].ПолучитьИмяПредопределенного(Значение);
			  |    ИначеЕсли Метаданные.ПланыВидовРасчета.Содержит(МетаданныеЗначения) Тогда
			  |        ИмяПредопределенныхДанных = ПланыВидовРасчета[МетаданныеЗначения.Имя].ПолучитьИмяПредопределенного(Значение);
			  |    ИначеЕсли Метаданные.ПланыОбмена.Содержит(МетаданныеЗначения) Тогда
			  |        ИмяПредопределенныхДанных = ""ЭтотУзел"";
			  |    КонецЕсли;
			  |КонецЕсли;";
	Если ЗначениеЗаполнено(Значение) Тогда
		Это83 = Истина;
		Попытка
			Выполнить(Текст83);
		Исключение
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			Это83 = Ложь;
		КонецПопытки;
		Если НЕ Это83 Тогда
			Попытка
				Выполнить(Текст82);
			Исключение
				ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			КонецПопытки;
		КонецЕсли;
	КонецЕсли;
		
	Возврат ИмяПредопределенныхДанных;	
	
КонецФункции //ПолучитьИмяПредопределенныхДанных()
	
// Функция "расщепляет" строку на подстроки, используя заданный 
//		разделитель. Разделитель может иметь любую длину. 
//		Если в качестве разделителя задан пробел, рядом стоящие пробелы 
//		считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//		игнорируются.
//
//	Параметры: 
//		Стр            -    строка, которую необходимо разложить на подстроки. 
//		                    Параметр передается по значению.
//		Разделитель    -    строка-разделитель, по умолчанию - запятая.
//		ВключатьПустые -    Указывает необходимость включать в результат пустые строки.
//
//
//	Возвращаемое значение:
//		массив значений, элементы которого - подстроки
//
Функция РазложитьСтроку(Знач Стр, Разделитель = ",", ВключатьПустые = Истина) Экспорт
	
	Попытка
		Возврат СтрРазделить(Стр, Разделитель, ВключатьПустые);
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	МассивСтрок = Новый Массив();
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока Истина Цикл
			Поз = Найти(Стр, Разделитель);
			Если Поз = 0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр, Поз - 1));
			Стр = СокрЛ(Сред(Стр, Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока Истина Цикл
			Поз = Найти(Стр, Разделитель);
			Если Поз = 0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			Значение = Лев(Стр, Поз - 1);
			Если НЕ ПустаяСтрока(Значение) ИЛИ ВключатьПустые Тогда
				МассивСтрок.Добавить(Значение);
			КонецЕсли;
			Стр = Сред(Стр, Поз + ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;
	
КонецФункции // РазложитьСтроку()

// Проверяет использование свойства (по имени) в соответствии со списками используемых и исключаемых свойств
//
// Параметры:
//  ИмяСвойства			- Строка					- Имя проверяемого свойства
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Булево				- Истина - свойство используется; Ложь - свойство не используется
//
Функция ИспользоватьСвойство(Знач ИмяСвойства, Знач СписокСвойств = Неопределено, Знач ИсключаяСвойства = Неопределено)
	
	Если ТипЗнч(СписокСвойств) = Тип("Строка") Тогда
		СписокСвойств = РазложитьСтроку(СписокСвойств, ",", Ложь);
	КонецЕсли;
	Если НЕ ТипЗнч(СписокСвойств) = Тип("Массив") Тогда
		СписокСвойств = Новый Массив();
	КонецЕсли;
	
	Если ТипЗнч(ИсключаяСвойства) = Тип("Строка") Тогда
		ИсключаяСвойства = РазложитьСтроку(ИсключаяСвойства, ",", Ложь);
	КонецЕсли;
	Если НЕ ТипЗнч(ИсключаяСвойства) = Тип("Массив") Тогда
		ИсключаяСвойства = Новый Массив();
	КонецЕсли;
	
	Если СписокСвойств.Количество() = 0 И ИсключаяСвойства.Количество() = 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если НЕ ИсключаяСвойства.Найти(ИмяСвойства) = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат (НЕ СписокСвойств.Найти(ИмяСвойства) = Неопределено) ИЛИ СписокСвойств.Количество() = 0;
	
КонецФункции //ИспользоватьСвойство()

// Преобразует описание типов в структуру
//
// Параметры:
//  ОписаниеТипов			- ОписаниеТипов				- Преобразуемое значение
//
// Возвращаемое значение:
//   Структура			- результат преобразования
//	   Типы							- Массив			- Список типов
//	   КвалификаторыЧисла			- Структура			- Описание квалификаторов числа
//		   Разрядность					- Число				- Разрядность
//		   РазрядностьДробнойЧасти		- Число				- Разрядность дробной части
//		   ДопустимыйЗнак				- ДопустимыйЗнак	- Допустимый знак
//	   КвалификаторыСтроки			- Структура			- Описание квалификаторов строки
//		   Длина						- Число				- Длина
//		   ДопустимаяДлина				- ДопустимаяДлина	- Разрядность дробной части
//	   КвалификаторыДаты			- Структура			- Описание квалификаторов даты
//		   ЧастиДаты					- ЧастиДаты			- Части даты (Дата / Время)
//	   КвалификаторыДвоичныхДанных	- Структура			- Описание квалификаторов двоичных данных
//		   Длина						- Число				- Длина
//		   ДопустимаяДлина				- ДопустимаяДлина	- Разрядность дробной части
//
Функция ОписаниеТиповВСтруктуру(ОписаниеТипов) Экспорт
	
	СтруктураОписаниеТипов = Новый Структура("Типы,
											 |КвалификаторыЧисла,
											 |КвалификаторыСтроки,
											 |КвалификаторыДаты,
											 |КвалификаторыДвоичныхДанных"
										    , Новый Массив()
										    , Новый Структура("Разрядность, РазрядностьДробнойЧасти, ДопустимыйЗнак", 10, 0)
										    , Новый Структура("Длина, ДопустимаяДлина", 10, "Переменная")
										    , Новый Структура("ЧастиДаты", "ДатаВремя")
										    , Новый Структура("Длина, ДопустимаяДлина", 0, "Переменная"));
								   
	Для Каждого ТекТип Из ОписаниеТипов.Типы() Цикл
		МетаТип = Метаданные.НайтиПоТипу(ТекТип);
		Если НЕ МетаТип = Неопределено Тогда
			СтруктураОписаниеТипов.Типы.Добавить(МетаТип.ПолноеИмя());
		Иначе
			СтруктураОписаниеТипов.Типы.Добавить(СокрЛП(ТекТип));
		КонецЕсли;
	КонецЦикла;
	
	СтруктураОписаниеТипов.КвалификаторыЧисла.Разрядность				= ОписаниеТипов.КвалификаторыЧисла.Разрядность;
	СтруктураОписаниеТипов.КвалификаторыЧисла.РазрядностьДробнойЧасти	= ОписаниеТипов.КвалификаторыЧисла.РазрядностьДробнойЧасти;
	СтруктураОписаниеТипов.КвалификаторыЧисла.ДопустимыйЗнак			=
		?(ОписаниеТипов.КвалификаторыЧисла.ДопустимыйЗнак = ДопустимыйЗнак.Неотрицательный, "Неотрицательный", "Любой");
	
	СтруктураОписаниеТипов.КвалификаторыСтроки.Длина			= ОписаниеТипов.КвалификаторыСтроки.Длина;
	СтруктураОписаниеТипов.КвалификаторыСтроки.ДопустимаяДлина	=
		?(ОписаниеТипов.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Фиксированная, "Фиксированная", "Переменная");
	
	СтруктураОписаниеТипов.КвалификаторыДаты.ЧастиДаты	=
		?(ОписаниеТипов.КвалификаторыДаты.ЧастиДаты = ЧастиДаты.Время,
		  "Время",
		  ?(ОписаниеТипов.КвалификаторыДаты.ЧастиДаты = ЧастиДаты.Дата, "Дата", "ДатаВремя"));
	
	СтруктураОписаниеТипов.КвалификаторыДвоичныхДанных.Длина			= ОписаниеТипов.КвалификаторыДвоичныхДанных.Длина;
	СтруктураОписаниеТипов.КвалификаторыДвоичныхДанных.ДопустимаяДлина	=
		?(ОписаниеТипов.КвалификаторыДвоичныхДанных.ДопустимаяДлина = ДопустимаяДлина.Фиксированная, "Фиксированная", "Переменная");
		
	Возврат СтруктураОписаниеТипов;
	
КонецФункции

// Получает описание типов из структуры
//
// Параметры:
//   СтруктураОписаниеТипов			- Структура			- структура описания типов для преобразования
//	   Типы								- Массив			- Список типов
//	   КвалификаторыЧисла				- Структура			- Описание квалификаторов числа
//		   Разрядность						- Число				- Разрядность
//		   РазрядностьДробнойЧасти			- Число				- Разрядность дробной части
//		   ДопустимыйЗнак					- ДопустимыйЗнак	- Допустимый знак
//	   КвалификаторыСтроки				- Структура			- Описание квалификаторов строки
//		   Длина							- Число				- Длина
//		   ДопустимаяДлина					- ДопустимаяДлина	- Разрядность дробной части
//	   КвалификаторыДаты				- Структура			- Описание квалификаторов даты
//		   ЧастиДаты						- ЧастиДаты			- Части даты (Дата / Время)
//	   КвалификаторыДвоичныхДанных		- Структура			- Описание квалификаторов двоичных данных
//		   Длина							- Число				- Длина
//		   ДопустимаяДлина					- ДопустимаяДлина	- Разрядность дробной части
//
// Возвращаемое значение:
//  ОписаниеТипов			- Созданное описание типов
//
Функция ОписаниеТиповИзСтруктуры(СтруктураОписаниеТипов) Экспорт
	
	МассивТипов = Новый Массив();
	
	Для Каждого ТекТип Из СтруктураОписаниеТипов.Типы Цикл
		Попытка
			НовыйТип = Тип(СтрЗаменить(ТекТип, ".", "Ссылка."));
			МассивТипов.Добавить(НовыйТип);
		Исключение
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			Продолжить;
		КонецПопытки;
	КонецЦикла;
		
	КвалификаторыЧисла = Новый КвалификаторыЧисла(СтруктураОписаниеТипов.КвалификаторыЧисла.Разрядность,
												  СтруктураОписаниеТипов.КвалификаторыЧисла.РазрядностьДробнойЧасти,
												  Вычислить("ДопустимыйЗнак." + СтруктураОписаниеТипов.КвалификаторыЧисла.ДопустимыйЗнак));
	
	КвалификаторыСтроки = Новый КвалификаторыСтроки(СтруктураОписаниеТипов.КвалификаторыСтроки.Длина,
													Вычислить("ДопустимаяДлина." + СтруктураОписаниеТипов.КвалификаторыСтроки.ДопустимаяДлина));
	
	КвалификаторыДаты = Новый КвалификаторыДаты(Вычислить("ЧастиДаты." + СтруктураОписаниеТипов.КвалификаторыДаты.ЧастиДаты));
	
	КвалификаторыДвоичныхДанных = Новый КвалификаторыДвоичныхДанных(СтруктураОписаниеТипов.КвалификаторыСтроки.Длина,
																	Вычислить("ДопустимаяДлина." + СтруктураОписаниеТипов.КвалификаторыДвоичныхДанных.ДопустимаяДлина));
																		  
	Возврат Новый ОписаниеТипов(МассивТипов, КвалификаторыЧисла, КвалификаторыСтроки, КвалификаторыДаты, КвалификаторыДвоичныхДанных);
	
КонецФункции

// Проверяет использование свойства объекта и добавляет в структуру
//
// Параметры:
//  СтруктураОбъекта	- Структура					- Заполняемая структура объекта
//  Объект				- Объект, ЛюбаяСсылка		- Преобразуемый объект
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ИмяСвойства, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено)
	
	Если НЕ ИспользоватьСвойство(ИмяСвойства, СписокСвойств, ИсключаяСвойства) Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураОбъекта.Вставить(ИмяСвойства, ЗначениеВСтруктуру(Объект[ИмяСвойства]));
	
КонецПроцедуры //СвойствоОбъектаВСтруктуру()
	
// Проверяет использование свойства объекта и заполняет значение свойства из структуры
//
// Параметры:
//  Объект				- Объект					- Заполняемый объект
//  СтруктураОбъекта	- Структура					- Структура объекта
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, ИмяСвойства, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено)
	
	Если НЕ СтруктураОбъекта.Свойство(ИмяСвойства) Тогда
		Возврат;
	КонецЕсли;
	
	Если НЕ ИспользоватьСвойство(ИмяСвойства, СписокСвойств, ИсключаяСвойства) Тогда
		Возврат;
	КонецЕсли;
	
	Объект[ИмяСвойства] = ЗначениеИзСтруктуры(СтруктураОбъекта[ИмяСвойства]);
	
КонецПроцедуры //СвойствоОбъектаИзСтруктуры()
	
// Добавляет данные табличной части объекта в структуру
//
// Параметры:
//  СтруктураОбъекта	- Структура					- Заполняемая структура объекта
//  Объект				- Объект, ЛюбаяСсылка		- Преобразуемый объект
//  ИмяТЧ				- Строка					- Имя преобразуемой табличной части
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ИмяТЧ, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено)
	
	Если НЕ ИспользоватьСвойство("__ТЧ." + ИмяТЧ, СписокСвойств, ИсключаяСвойства) Тогда
		Возврат;
	КонецЕсли;
	
	Если НЕ СтруктураОбъекта.Свойство("__ТЧ") Тогда
		СтруктураОбъекта.Вставить("__ТЧ", Новый Структура());
	КонецЕсли;
	
	МетаОбъект = Объект.Метаданные();
	
	МетаТЧ = МетаОбъект.ТабличныеЧасти.Найти(ИмяТЧ);
	
	Если МетаТЧ = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	МассивСтрок = Новый Массив();
	Для Каждого ТекСтрока Из Объект[ИмяТЧ] Цикл
		
		СтруктураСтроки = Новый Структура();
		СтруктураСтроки.Вставить("__Индекс", Объект[ИмяТЧ].Индекс(ТекСтрока));
		СтруктураСтроки.Вставить("НомерСтроки", ТекСтрока.НомерСтроки);
		
		Для Каждого ТекРеквизит Из МетаТЧ.Реквизиты Цикл
			Если НЕ ИспользоватьСвойство(ИмяТЧ + "." + ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекРеквизит.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекРеквизит.Имя]));
		КонецЦикла;
		
		МассивСтрок.Добавить(СтруктураСтроки);
		
	КонецЦикла;
	
	СтруктураОбъекта.__ТЧ.Вставить(ИмяТЧ, МассивСтрок);
	
КонецПроцедуры //ТЧОбъектаВСтруктуру()

// Заполняет табличную часть объекта из структуры
//
// Параметры:
//  Объект				- Объект, ЛюбаяСсылка		- Заполняемый объект
//  СтруктураОбъекта	- Структура					- Структура данных объекта
//  ИмяТЧ				- Строка					- Имя преобразуемой табличной части
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ТЧОбъектаИзСтруктуры(Объект, СтруктураОбъекта, ИмяТЧ, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено)
	
	Если НЕ СтруктураОбъекта.Свойство("__ТЧ") Тогда
		Возврат;
	КонецЕсли;
		
	Если НЕ СтруктураОбъекта.__ТЧ.Свойство(ИмяТЧ) Тогда
		Возврат;
	КонецЕсли;
		
	Если НЕ ИспользоватьСвойство("__ТЧ." + ИмяТЧ, СписокСвойств, ИсключаяСвойства) Тогда
		Возврат;
	КонецЕсли;
	
	МетаОбъект = Объект.Метаданные();
	
	МетаТЧ = МетаОбъект.ТабличныеЧасти.Найти(ИмяТЧ);
	
	Если МетаТЧ = Неопределено Тогда
		Возврат;
	КонецЕсли;

	Объект[ИмяТЧ].Очистить();
	
	МассивСтрок = СтруктураОбъекта.__ТЧ[ИмяТЧ];
	
	Для Каждого ТекСтрока Из МассивСтрок Цикл
		
		НоваяСтрока = Объект[ИмяТЧ].Добавить();
		
		Для Каждого ТекРеквизит Из МетаТЧ.Реквизиты Цикл
			
			Если НЕ ТекСтрока.Свойство(ТекРеквизит.Имя) Тогда
				Продолжить;
			КонецЕсли;
			
			Если НЕ ИспользоватьСвойство(ИмяТЧ + "." + ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			
			НоваяСтрока[ТекРеквизит.Имя] = ЗначениеИзСтруктуры(ТекСтрока[ТекРеквизит.Имя]);
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры //ТЧОбъектаИзСтруктуры()
	
// Преобразует значения субконто записи регистра бухгалтерии в структуру
//
// Параметры:
//  Запись				- РегистрБухгалтерииЗапись	- Преобразуемая запись регистра бухгалтерии
//  ДтКт				- Строка					- признак Дт/Кт - "Дт", "Кт", "" 
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Массив(Структура)			- результат преобразования
//		НомерСтроки		- Число								- Номер субконто
//		ВидСубконто		- ПланВидовХарактеристикСсылка		- Вид субконто
//		Значение		- Произвольный						- Значение субконто
//
Функция ЗначенияСубконтоЗаписиВСтруктуру(Запись, ДтКт = "", СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено)
	
	ВидыСубконто = Запись["Счет" + ДтКт].ВидыСубконто;
	ЗначенияСубконто = Запись["Субконто" + ДтКт];
	
	МассивСубконто = Новый Массив();
	й = 1;
	Для Каждого ТекСтрокаВида Из ВидыСубконто Цикл
		Если НЕ ИспользоватьСвойство("Субконто" + ДтКт + Формат(й, "ЧДЦ=; ЧГ="), СписокСвойств, ИсключаяСвойства) Тогда
			й = й + 1;
			Продолжить;
		КонецЕсли;
		МассивСубконто.Добавить(Новый Структура("НомерСтроки, ВидСубконто, Значение"
												, й
												, ЗначениеВСтруктуру(ТекСтрокаВида.ВидСубконто)
												, ЗначениеВСтруктуру(ЗначенияСубконто[ТекСтрокаВида.ВидСубконто])));
		й = й + 1;
	КонецЦикла;
	
	Возврат МассивСубконто;
	
КонецФункции //ЗначенияСубконтоВСтруктуру()

// Заполняет значения субконто записи регистра бухгалтерии из структуры
//
// Параметры:
//  Запись				- РегистрБухгалтерииЗапись	- Заполняемая запись регистра бухгалтерии
//  СтруктураЗаписи		- Структура					- Структура данных записи регистра бухгалтерии 
//  ДтКт				- Строка					- признак Дт/Кт - "Дт", "Кт", "" 
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ЗначенияСубконтоЗаписиИзСтруктуры(Запись, СтруктураЗаписи, ДтКт = "", СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено)
	
	ВидыСубконто = Запись["Счет" + ДтКт].ВидыСубконто;
	ЗначенияСубконто = Запись["Субконто" + ДтКт];
	
	МассивСубконто = СтруктураЗаписи["Субконто" + ДтКт];
	
	й = 1;
	Для Каждого ТекСтрока Из МассивСубконто Цикл
		
		Если НЕ ИспользоватьСвойство("Субконто" + ДтКт + Формат(й, "ЧДЦ=; ЧГ="), СписокСвойств, ИсключаяСвойства) Тогда
			й = й + 1;
			Продолжить;
		КонецЕсли;
		
		ВидСубконто = ЗначениеИзСтруктуры(ТекСтрока.ВидСубконто);
		
		Если НЕ ЗначениеЗаполнено(ВидСубконто) Тогда
			й = й + 1;
			Продолжить;
		КонецЕсли;
		
		СтрокаВида = ВидыСубконто.Найти(ВидСубконто, "ВидСубконто");
		
		Если СтрокаВида = Неопределено Тогда
			й = й + 1;
			Продолжить;
		КонецЕсли;
		
		ЗначенияСубконто[ВидСубконто] = ЗначениеИзСтруктуры(ТекСтрока.Значение);
		
		й = й + 1;
		
	КонецЦикла;
	
КонецПроцедуры //ЗначенияСубконтоИзСтруктуры()

// Заполняет значение измерения записи регистра бухгалтерии из структуры
// с учетом признаков учета счета
//
// Параметры:
//  Запись				- РегистрБухгалтерииЗапись		- Заполняемая запись регистра бухгалтерии
//  СтруктураЗаписи		- Структура						- Структура данных записи регистра бухгалтерии 
//  ОписаниеПоля		- ОбъектМетаданных.Измерение	- Описание метаданных измерения регистра 
//  ДтКт				- Строка						- признак Дт/Кт - "Дт", "Кт", "" 
//
Процедура ЗаполнитьИзмерениеРегистраБухгалтерии(Запись, СтруктураЗаписи, ОписаниеПоля, ДтКт)
	
	ЗаполнятьЗначение = Истина;
	
	Если ЗначениеЗаполнено(ОписаниеПоля.ПризнакУчета) Тогда
		Если НЕ Запись["Счет" + ДтКт][ОписаниеПоля.ПризнакУчета.Имя] Тогда
			ЗаполнятьЗначение = Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Если ЗаполнятьЗначение Тогда
		Запись[ОписаниеПоля.Имя + ДтКт] = ЗначениеИзСтруктуры(СтруктураЗаписи[ОписаниеПоля.Имя + ДтКт]);
	КонецЕсли;
	
КонецПроцедуры //ЗаполнитьИзмерениеРегистраБухгалтерии()

// Заполняет значение ресурса записи регистра бухгалтерии из структуры
// с учетом признаков учета счета
//
// Параметры:
//  Запись				- РегистрБухгалтерииЗапись		- Заполняемая запись регистра бухгалтерии
//  СтруктураЗаписи		- Структура						- Структура данных записи регистра бухгалтерии 
//  ОписаниеПоля		- ОбъектМетаданных.Ресурс		- Описание метаданных ресурса регистра 
//  ДтКт				- Строка						- признак Дт/Кт - "Дт", "Кт", "" 
//
Процедура ЗаполнитьРесурсРегистраБухгалтерии(Запись, СтруктураЗаписи, ОписаниеПоля, ДтКт)
	
	ЗаполнятьЗначение = Истина;
	
	Если ЗначениеЗаполнено(ОписаниеПоля.ПризнакУчета) Тогда
		Если НЕ Запись["Счет" + ДтКт][ОписаниеПоля.ПризнакУчета.Имя] Тогда
			ЗаполнятьЗначение = Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Если ЗаполнятьЗначение Тогда
		Запись[ОписаниеПоля.Имя + ДтКт] = ЗначениеИзСтруктуры(СтруктураЗаписи[ОписаниеПоля.Имя + ДтКт]);
	КонецЕсли;
	
КонецПроцедуры //ЗаполнитьРесурсРегистраБухгалтерии()

// Функция - возвращает представление описания объекта в текстовом формате JSON
//
// Параметры:
//  ОписаниеОбъекта	 - Структура, Массив(Структура)	 - описание объекта для преобразования
// 
// Возвращаемое значение:
//  Строка - представление описания объекта в текстовом формате JSON
//
Функция ЗаписатьОписаниеОбъектаВJSON(Знач ОписаниеОбъекта) Экспорт
	
	Запись = Новый ЗаписьJSON();
	Запись.УстановитьСтроку(Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Unix, Символы.Таб));
	
	НастройкиСериализации = Новый НастройкиСериализацииJSON();
	НастройкиСериализации.ВариантЗаписиДаты = ВариантЗаписиДатыJSON.УниверсальнаяДата;
	НастройкиСериализации.ФорматСериализацииДаты = ФорматДатыJSON.Microsoft;
	
	Попытка
		ЗаписатьJSON(Запись, ОписаниеОбъекта, НастройкиСериализации);
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	Возврат Запись.Закрыть();
	
КонецФункции // ЗаписатьОписаниеОбъектаВJSON()

// Функция - возвращает описание объекта, прочитанное из текстового формата JSON
//
// Параметры:
//  ТекстОписанияОбъекта       - Строка           - представление описания объекта в текстовом формате JSON
//  СвойстваСоЗначениемДата    - Массив, Строка   - список свойств, которые должны быть преобразованы в формат даты
// 
// Возвращаемое значение:
//  Структура, Массив(Структура)	 - описание объекта 
//
Функция ПрочитатьОписаниеОбъектаИзJSON(Знач ТекстОписанияОбъекта, Знач СвойстваСоЗначениемДата = Неопределено) Экспорт
	
	Чтение = Новый ЧтениеJSON();
	Чтение.УстановитьСтроку(ТекстОписанияОбъекта);
		
	Если ТипЗнч(СвойстваСоЗначениемДата) = Тип("Строка") Тогда
		СвойстваСоЗначениемДата = РазложитьСтроку(СвойстваСоЗначениемДата, ",", Ложь);
	ИначеЕсли НЕ ТипЗнч(СвойстваСоЗначениемДата) = Тип("Массив") Тогда
		СвойстваСоЗначениемДата = Новый Массив();
	КонецЕсли;
		
	Попытка
		Возврат ПрочитатьJSON(Чтение, Ложь, СвойстваСоЗначениемДата, ФорматДатыJSON.ISO);
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
КонецФункции // ПрочитатьОписаниеОбъектаИзJSON()

#КонецОбласти

#Область СохранениеЗначенийСлужебные

// Преобразует переданное значение в структуру, значения атомарных типов, возвращаются как есть
//
// Параметры:
//  Значение			- Произвольный				- Преобразуемое значение
//
// Возвращаемое значение:
//   Структура, Массив, Число, Строка, Дата, Булево			- результат преобразования
//
Функция ЗначениеВСтруктуру(Значение) Экспорт
	
	Если ТипЗнч(Значение) = Тип("Строка")
	 ИЛИ ТипЗнч(Значение) = Тип("Число")
	 ИЛИ ТипЗнч(Значение) = Тип("Булево")
	 ИЛИ ТипЗнч(Значение) = Тип("Дата") Тогда
		Возврат Значение;
	ИначеЕсли ТипЗнч(Значение) = Тип("ХранилищеЗначения") Тогда
		Возврат "/ValueStorage(" + ЗначениеВСтрокуВнутр(Значение) + ")/";
	ИначеЕсли ТипЗнч(Значение) = Тип("УникальныйИдентификатор") Тогда
		Возврат "/UniqueID(" + СокрЛП(Значение) + ")/";
	ИначеЕсли ТипЗнч(Значение) = Тип("Массив")
		  ИЛИ ТипЗнч(Значение) = Тип("ФиксированныйМассив") Тогда
		Возврат МассивВСтруктуру(Значение);
	ИначеЕсли ТипЗнч(Значение) = Тип("Структура")
		  ИЛИ ТипЗнч(Значение) = Тип("ФиксированнаяСтруктура") Тогда
		Возврат СтруктураВСтруктуру(Значение);
	ИначеЕсли ТипЗнч(Значение) = Тип("Соответствие")
		  ИЛИ ТипЗнч(Значение) = Тип("ФиксированноеСоответствие") Тогда
		Возврат СоответствиеВСтруктуру(Значение);
	ИначеЕсли ТипЗнч(Значение) = Тип("СписокЗначений") Тогда
		Возврат СписокЗначенийВСтруктуру(Значение);
	ИначеЕсли ТипЗнч(Значение) = Тип("ТаблицаЗначений") Тогда
		Возврат ТаблицаЗначенийВСтруктуру(Значение);
	ИначеЕсли ТипЗнч(Значение) = Тип("ДеревоЗначений") Тогда
		Возврат ДеревоЗначенийВСтруктуру(Значение);
	ИначеЕсли ТипЗнч(Значение) = Тип("ОписаниеТипов") Тогда
		Возврат ОписаниеТиповВСтруктуру(Значение);
	КонецЕсли;
	
	МетаОбъект = Метаданные.НайтиПоТипу(ТипЗнч(Значение));
	Если НЕ МетаОбъект = Неопределено Тогда
		Возврат СсылкаВСтруктуру(Значение);
	Иначе
		Возврат "/UnknownType(" + ЗначениеВСтрокуВнутр(Значение) + ")/";
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции //ЗначениеВСтруктуру()

// Преобразует переданную ссылку в структуру, значения атомарных типов, возвращаются как есть
//
// Параметры:
//  Значение			- ЛюбаяСсылка				- Преобразуемое ссылка
//
// Возвращаемое значение:
//   Структура			- результат преобразования
//
Функция СсылкаВСтруктуру(Значение) Экспорт
	
	МетаданныеЗначения = Метаданные.НайтиПоТипу(ТипЗнч(Значение));
	
	Если МетаданныеЗначения = Неопределено Тогда
		Возврат Значение;
	ИначеЕсли ВРег(Лев(МетаданныеЗначения.ПолноеИмя(), 13)) = ВРег("Перечисление.") Тогда
		ИмяПредопределенныхДанных = "";
		Если ЗначениеЗаполнено(Значение) Тогда
			Индекс = Перечисления[МетаданныеЗначения.Имя].Индекс(Значение);
			ИмяПредопределенныхДанных = МетаданныеЗначения.ЗначенияПеречисления.Получить(Индекс).Имя;
		КонецЕсли;
		ОписаниеЗначения = Новый Структура("Тип, Ид, ИдПолный, Предопределенный, ИмяПредопределенныхДанных, Представление"
										, МетаданныеЗначения.ПолноеИмя()
										, ИмяПредопределенныхДанных
										, ЗначениеВСтрокуВнутр(Значение)
										, Истина
										, ИмяПредопределенныхДанных
										, СокрЛП(Значение));
	Иначе
		Предопределенный = Ложь;
		Если Метаданные.Справочники.Содержит(МетаданныеЗначения)
		 ИЛИ Метаданные.ПланыВидовХарактеристик.Содержит(МетаданныеЗначения)
		 ИЛИ Метаданные.ПланыСчетов.Содержит(МетаданныеЗначения)
		 ИЛИ Метаданные.ПланыВидовРасчета.Содержит(МетаданныеЗначения) Тогда
			Предопределенный = Значение.Предопределенный;
		ИначеЕсли Метаданные.ПланыОбмена.Содержит(МетаданныеЗначения) Тогда
			Предопределенный = Значение.ЭтотУзел;
		КонецЕсли;
		ОписаниеЗначения = Новый Структура("Тип, Ид, ИдПолный, Предопределенный, ИмяПредопределенныхДанных, Представление"
										, МетаданныеЗначения.ПолноеИмя()
										, СокрЛП(Значение.УникальныйИдентификатор())
										, ЗначениеВСтрокуВнутр(Значение)
										, Предопределенный
										, ПолучитьИмяПредопределенныхДанных(Значение)
										, СокрЛП(Значение));
	КонецЕсли;
	
	ПравилоВыгрузки = ПолучитьПравилоВыгрузкиТипа(МетаданныеЗначения.ПолноеИмя());
	
	КодДополненияЗначения = "";
	Если НЕ ПравилоВыгрузки.Модуль = Неопределено Тогда
		КодДополненияЗначения = КодДополненияЗначения + "ПравилоВыгрузки.Модуль.";
	КонецЕсли;
	
	КодДополненияЗначения = КодДополненияЗначения + СокрЛП(ПравилоВыгрузки.ФункцияДополнения) + "(ОписаниеЗначения, Значение);";
	
	Попытка
		Выполнить(КодДополненияЗначения);
	Исключение
		ТекстОшибки = "Ошибка дополнения значения: " + СокрЛП(Значение) + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	Возврат ОписаниеЗначения;
	
КонецФункции //СсылкаВСтруктуру()

// Получает правило преобразования в структуру для указанного типа значений
//
// Параметры:
//  ПолноеИмяТипа			- Строка				- Имя типа преобразуемого значения
//
// Возвращаемое значение:
//	Структура					- Правило выгрузки типа
//		ФункцияДополнения	- Строка			- Имя функции дополнительной обработки данных при выгрузке
//
Функция ПолучитьПравилоВыгрузкиТипа(ПолноеИмяТипа)
	
	Правила = ПолучитьПравилаВыгрузкиТипов();
	
	Правило = Правила[ПолноеИмяТипа];
	
	Если Правило = Неопределено Тогда
		Правило = Новый Структура("ФункцияДополнения, Модуль", "ДополнитьОписаниеЗначения");
	КонецЕсли;
	
	Возврат Правило;
	
КонецФункции //ПолучитьПравилоВыгрузкиТипа()

// Добавляет правило преобразования в структуру для указанного типа значений
//
// Параметры:
//	ТипИсточника           - Строка                   - Имя типа преобразуемого значения
//	ФункцияДополнения      - Строка                   - Имя функции преобразования значения
//  Модуль                 - УправляемаяФорма, Модуль - модуль, содержащий функцию дополнения,
//                                                      Неопределено - функция будет вызвана
//                                                      из модуля обработки (этот модуль)
//
Процедура ДобавитьПравилоВыгрузкиТипа(ТипИсточника, ФункцияДополнения, Модуль = Неопределено) Экспорт
	
	Если НЕ ТипЗнч(ПравилаВыгрузкиТипов) = Тип("Соответствие") Тогда
		ПравилаВыгрузкиТипов = Новый Соответствие();
	КонецЕсли;
	
	ПравилаВыгрузкиТипов.Вставить(ТипИсточника, Новый Структура("ФункцияДополнения, Модуль", ФункцияДополнения, Модуль));
	
КонецПроцедуры //ДобавитьПравилоВыгрузкиТипа()

#КонецОбласти

#Область СохранениеЗначенийПереопределяемые

// Переопределяемая процедура, позволяющая дополнить алгоритмы преобразования данных в структуру
//
// Параметры:
//
// Возвращаемое значение:
//   Соответствие			- правила выгрузки типов
//		<ТипЗначения>			- Структура			- Имя выгружаемого типа значения
//			ФункцияДополнения	- Строка			- Имя функции дополнительной обработки данных при выгрузке
//
Функция ПолучитьПравилаВыгрузкиТипов()
	
	Если НЕ ТипЗнч(ПравилаВыгрузкиТипов) = Тип("Соответствие") Тогда
		ПравилаВыгрузкиТипов = Новый Соответствие();
	КонецЕсли;
	
	Возврат ПравилаВыгрузкиТипов;
	
КонецФункции //ПолучитьПравилаВыгрузкиТипов()

// Шаблон процедуры дополнения данных при преобразовании в структуру
//
// Параметры:
// 		ОписаниеЗначения		- Структура			- Структура значения для дополнения
//		Значение				- Произвольный		- Преобразуемое значение
//
Процедура ДополнитьОписаниеЗначения(ОписаниеЗначения, Значение)
	
КонецПроцедуры //ДополнитьОписаниеЗначения()

#КонецОбласти

#Область ПолучениеЗначенийСлужебные

// Получает значение из переданного описания, значения атомарных типов, возвращаются как есть
//
// Параметры:
//  СтруктураЗначения          - Структура, Число, Строка,      - Описание значение
//                               Дата, Булево
//  ПолучатьБитыеСсылки        - Булево                         - Истина - если объект по ссылке не существует,
//                                                                будет возвращена битая ссылка;
//                                                                Ложь - будет возвращена пустая ссылка
//
// Возвращаемое значение:
//   Произвольный			- результат преобразования
//
Функция ЗначениеИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки = Ложь) Экспорт
	
	Если ТипЗнч(СтруктураЗначения) = Тип("Строка") Тогда
		Если Лев(СтруктураЗначения, 1) = "/" Тогда
			Если Лев(СтруктураЗначения, 6) = "/Date(" Тогда
				Если Прав(СтруктураЗначения, 2) = ")/" Тогда
					СмещениеДаты = Число(Сред(СтруктураЗначения, 7, СтрДлина(СтруктураЗначения) - 8)) / 1000;
					Возврат Дата('19700101') + СмещениеДаты + СмещениеСтандартногоВремени(, Дата('19700101') + СмещениеДаты);
				КонецЕсли;
			ИначеЕсли Лев(СтруктураЗначения, 14) = "/ValueStorage(" Тогда
				Если Прав(СтруктураЗначения, 2) = ")/" Тогда
					Возврат ЗначениеИзСтрокиВнутр(Сред(СтруктураЗначения, 15, СтрДлина(СтруктураЗначения) - 16));
				КонецЕсли;
			ИначеЕсли Лев(СтруктураЗначения, 10) = "/UniqueID(" Тогда
				Если Прав(СтруктураЗначения, 2) = ")/" Тогда
					Возврат Новый УникальныйИдентификатор(Сред(СтруктураЗначения, 11, СтрДлина(СтруктураЗначения) - 12));
				КонецЕсли;
			ИначеЕсли Лев(СтруктураЗначения, 13) = "/UnknownType(" Тогда
				Если Прав(СтруктураЗначения, 2) = ")/" Тогда
					Возврат ЗначениеИзСтрокиВнутр(Сред(СтруктураЗначения, 14, СтрДлина(СтруктураЗначения) - 15));
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Возврат СтруктураЗначения;
	ИначеЕсли ТипЗнч(СтруктураЗначения) = Тип("Число")
	 ИЛИ ТипЗнч(СтруктураЗначения) = Тип("Булево")
	 ИЛИ ТипЗнч(СтруктураЗначения) = Тип("Дата")
	 ИЛИ ТипЗнч(СтруктураЗначения) = Тип("ХранилищеЗначения") Тогда
		Возврат СтруктураЗначения;
	КонецЕсли;
	
	ВремТип = СтруктураТипЗнч(СтруктураЗначения);
	
	Если ВремТип = Тип("Массив") Тогда
		Возврат МассивИзСтруктуры(СтруктураЗначения);
	ИначеЕсли ВремТип = Тип("Структура") Тогда
		Возврат СтруктураИзСтруктуры(СтруктураЗначения);
	ИначеЕсли ВремТип = Тип("Соответствие") Тогда
		Возврат СоответствиеИзСтруктуры(СтруктураЗначения);
	ИначеЕсли ВремТип = Тип("СписокЗначений") Тогда
		Возврат СписокЗначенийИзСтруктуры(СтруктураЗначения);
	ИначеЕсли ВремТип = Тип("ТаблицаЗначений") Тогда
		Возврат ТаблицаЗначенийИзСтруктуры(СтруктураЗначения);
	ИначеЕсли ВремТип = Тип("ДеревоЗначений") Тогда
		Возврат ДеревоЗначенийИзСтруктуры(СтруктураЗначения);
	ИначеЕсли ВремТип = Тип("ОписаниеТипов") Тогда
		Возврат ОписаниеТиповИзСтруктуры(СтруктураЗначения);
	КонецЕсли;
	
	МетаОбъект = Метаданные.НайтиПоТипу(ВремТип);
	Если НЕ МетаОбъект = Неопределено Тогда
		Возврат СсылкаИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки);
	КонецЕсли;
	
	Возврат СтруктураЗначения;
	
КонецФункции //ЗначениеИзСтруктуры()

// Получает ссылку по переданной структуре
//
// Параметры:
//  ОписаниеЗначения			- Структура			- Структура описания ссылки
//  ПолучатьБитыеСсылки         - Булево            - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//
// Возвращаемое значение:
//   ЛюбаяСсылка			- полученная ссылка
//
Функция СсылкаИзСтруктуры(ОписаниеЗначения, ПолучатьБитыеСсылки = Ложь) Экспорт
	
	Если Не ТипЗнч(ОписаниеЗначения) = Тип("Структура") Тогда
		Возврат ОписаниеЗначения;
	КонецЕсли;
	
	ПравилоЗагрузки = ПолучитьПравилоЗагрузкиТипа(ОписаниеЗначения.Тип);
	
	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ПравилоЗагрузки.ТипЗначения);

	МетаОбъект = Метаданные.НайтиПоПолномуИмени(ПравилоЗагрузки.ТипЗначения);
	
	Если МетаОбъект = Неопределено Тогда
		ТекстОшибки = "Не найден тип " + ПравилоЗагрузки.ТипЗначения 
		            + " для значения: """
		            + ОписаниеЗначения.Представление
		            + " (" + ОписаниеЗначения.Ид + ")""";
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Коллекция = ОписаниеВида.Коллекция;
	
	Результат = Коллекция[МетаОбъект.Имя].ПустаяСсылка();
	
	Если НЕ Найти(ОписаниеЗначения.ИдПолный, "00000000000000000000000000000000") = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	КодПоискаСсылки = "Результат = ";
	Если НЕ ПравилоЗагрузки.Модуль = Неопределено Тогда
		КодПоискаСсылки = КодПоискаСсылки + "ПравилоЗагрузки.Модуль.";
	КонецЕсли;
	
	КодПоискаСсылки = КодПоискаСсылки + СокрЛП(ПравилоЗагрузки.ФункцияПоиска) + "(ОписаниеВида, МетаОбъект, ОписаниеЗначения);";
	
	Попытка
		Выполнить(КодПоискаСсылки);
	Исключение
		ТекстОшибки = "Ошибка поиска ссылки по описанию: " + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	Если НЕ ЗначениеЗаполнено(Результат) Тогда
		Сообщить("Не найдено значение "
			+ МетаОбъект.ПолноеИмя() + ": """
			+ ОписаниеЗначения.Представление
			+ " (" + ОписаниеЗначения.Ид + ")""");
		Если ПолучатьБитыеСсылки Тогда
			Результат = Коллекция[МетаОбъект.Имя].ПолучитьСсылку(Новый УникальныйИдентификатор(ОписаниеЗначения.Ид));
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции //СсылкаИзСтруктуры()

// Получает правило преобразования данных из структуры для указанного типа значений
//
// Параметры:
//  ПолноеИмяТипа			- Строка				- Имя типа преобразуемого значения
//
// Возвращаемое значение:
//	Структура					- Правило выгрузки типа
//		ТипЗначения			- Строка			- Имя типа значения целевых данных
//		ФункцияПоиска		- Строка			- Имя функции поиска значения
//
Функция ПолучитьПравилоЗагрузкиТипа(ПолноеИмяТипа)
	
	Правила = ПолучитьПравилаЗагрузкиТипов();
	
	Правило = Правила[ПолноеИмяТипа];
	
	Если Правило = Неопределено Тогда
		Правило = Новый Структура("ТипЗначения, ФункцияПоиска, Модуль", ПолноеИмяТипа, "НайтиЗначениеПоОписанию");
	КонецЕсли;
	
	Возврат Правило;
	
КонецФункции //ПолучитьПравилоЗагрузкиТипа()

// Добавляет правило преобразования данных из структуры для указанного типа значений
//
// Параметры:
//	ТипИсточника             - Строка                   - Имя типа преобразуемого значения
//	ТипПриемника             - Строка                   - Имя типа целевого значения
//	ФункцияПоиска            - Строка                   - Имя функции поиска значения
//  Модуль                   - УправляемаяФорма, Модуль - модуль, содержащий функцию поиска,
//                                                        Неопределено - функция будет вызвана
//                                                        из модуля обработки (этот модуль)
//
Процедура ДобавитьПравилоЗагрузкиТипа(ТипИсточника, ТипПриемника, ФункцияПоиска, Модуль = Неопределено) Экспорт
	
	Если НЕ ТипЗнч(ПравилаЗагрузкиТипов) = Тип("Соответствие") Тогда
		ПравилаЗагрузкиТипов = Новый Соответствие();
	КонецЕсли;
	
	ПравилаЗагрузкиТипов.Вставить(ТипИсточника, Новый Структура("ТипЗначения, ФункцияПоиска, Модуль", ТипПриемника, ФункцияПоиска, Модуль));
	
КонецПроцедуры //ДобавитьПравилоЗагрузкиТипа()

#КонецОбласти

#Область ПолучениеЗначенийПереопределяемые

// Переопределяемая процедура, позволяющая дополнить алгоритмы преобразования данных из структуры
//
// Параметры:
//
// Возвращаемое значение:
//   Соответствие(Структура)			- правила выгрузки типов
//		<ТипЗначения>			- Строка			- Имя типа значения преобразованных данных
//		ТипЗначения					- Строка			- Имя типа значения целевых данных
//		ФункцияПоиска				- Строка			- Имя функции поиска значения
//
Функция ПолучитьПравилаЗагрузкиТипов()
	
	Если НЕ ТипЗнч(ПравилаЗагрузкиТипов) = Тип("Соответствие") Тогда
		ПравилаЗагрузкиТипов = Новый Соответствие();
	КонецЕсли;
	
	Возврат ПравилаЗагрузкиТипов;
	
КонецФункции //ПолучитьПравилаЗагрузкиТипов()

// Функция поиска значений по структуре описания (шаблон процедуры поиска)
// Ищет значение по имени предопределенных данных, затем по полному иидентификатору, затем по представлению (наименованию)
//
// Параметры:
//		ОписаниеВида			- Структура				- Описание вида значения
//		МетаОбъект				- ОписаниеМетаданных	- Описание метаданных обрабатываемого типа значений
// 		ОписаниеЗначения		- Структура				- Структура значения для обработки
//
// Возвращаемое значение:
//   ЛюбаяСсылка			- найденное значение
//
Функция НайтиЗначениеПоОписанию(ОписаниеВида, МетаОбъект, ОписаниеЗначения)
	
	Коллекция = ОписаниеВида.Коллекция;
	
	Если ЗначениеЗаполнено(ОписаниеЗначения.ИмяПредопределенныхДанных) Тогда
		Если ВРег(ОписаниеВида.Имя) = ВРег("ПланОбмена")
		   И ВРег(ОписаниеЗначения.ИмяПредопределенныхДанных) = ВРег("ЭтотУзел") Тогда
			Возврат Коллекция[МетаОбъект.Имя].ЭтотУзел();
		Иначе
			Возврат Коллекция[МетаОбъект.Имя][ОписаниеЗначения.ИмяПредопределенныхДанных];
		КонецЕсли;
	Иначе
		ВремСсылка = ЗначениеИзСтрокиВнутр(ОписаниеЗначения.ИдПолный);
		Если ЗначениеЗаполнено(ВремСсылка) Тогда
			ВремОбъект = ВремСсылка.ПолучитьОбъект();
			Если НЕ ВремОбъект = Неопределено Тогда
				Возврат ВремСсылка;
			КонецЕсли;
		КонецЕсли;
		
		Если Найти(ОписаниеЗначения.ИдПолный, "00000000000000000000000000000000") = 0 Тогда
			ВремСсылка = Коллекция[МетаОбъект.Имя].ПолучитьСсылку(Новый УникальныйИдентификатор(ОписаниеЗначения.Ид));
			ВремОбъект = ВремСсылка.ПолучитьОбъект();
			Если НЕ ВремОбъект = Неопределено Тогда
				Возврат ВремСсылка;
			КонецЕсли;
		
		КонецЕсли;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ОписаниеЗначения.Представление)
	   И (ВРег(ОписаниеВида.Имя) = ВРег("Справочник")
			ИЛИ ВРег(ОписаниеВида.Имя) = ВРег("ПланВидовХарактеристик")
			ИЛИ ВРег(ОписаниеВида.Имя) = ВРег("ПланСчетов")
			ИЛИ ВРег(ОписаниеВида.Имя) = ВРег("ПланВидовРасчета")
			ИЛИ ВРег(ОписаниеВида.Имя) = ВРег("ПланОбмена")
			ИЛИ ВРег(ОписаниеВида.Имя) = ВРег("Задача")) Тогда
		
		ВремСсылка = Коллекция[МетаОбъект.Имя].НайтиПоНаименованию(ОписаниеЗначения.Представление, Истина); 
		Если НЕ ВремСсылка.Пустая() Тогда
			Возврат ВремСсылка;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Коллекция[МетаОбъект.Имя].ПустаяСсылка();
	
КонецФункции //НайтиЗначениеПоОписанию()

#КонецОбласти

#Область ПреобразованияКоллекций

// Функция определяет тип значения, сохраненного в массив или структуру
// для преобразования в значение 1С
//
// Параметры:
//		СтруктураЗначения		- Структура, Массив		- Проверяемое значения
//
// Возвращаемое значение:
//   Тип			- Тип 1С (Массив, Структура, Соответствие, СписокЗначений, ТаблицаЗначений, ДеревоЗначений, ЛюбаяСсылка)
//
Функция СтруктураТипЗнч(СтруктураЗначения)
	
	Если ТипЗнч(СтруктураЗначения) = Тип("Массив") Тогда
		Если СтруктураЗначения.Количество() = 0 Тогда
			Возврат Тип("Массив");
		КонецЕсли;
		Если ТипЗнч(СтруктураЗначения[0]) = Тип("Структура") Тогда
			Если СтруктураЗначения[0].Свойство("Ключ")
			   И СтруктураЗначения[0].Свойство("Значение") Тогда
				Возврат Тип("Соответствие");
			ИначеЕсли СтруктураЗначения[0].Свойство("Представление")
			   И СтруктураЗначения[0].Свойство("Значение")
			   И СтруктураЗначения[0].Свойство("Пометка") Тогда
				Возврат Тип("СписокЗначений");
			Иначе
				Возврат Тип("ТаблицаЗначений");
			КонецЕсли;
		КонецЕсли;
		Возврат Тип("Массив");
	ИначеЕсли ТипЗнч(СтруктураЗначения) = Тип("Структура") Тогда
		Если СтруктураЗначения.Свойство("Тип")
		   И СтруктураЗначения.Свойство("Ид")
		   И СтруктураЗначения.Свойство("ИдПолный") Тогда
			ПравилоЗагрузки = ПолучитьПравилоЗагрузкиТипа(СтруктураЗначения.Тип);
			Возврат Тип(СтрЗаменить(ПравилоЗагрузки.ТипЗначения, ".", "Ссылка."));
		КонецЕсли;
		Если СтруктураЗначения.Свойство("Ссылка") Тогда
			Если СтруктураЗначения.Свойство("Тип")
			   И СтруктураЗначения.Свойство("Ид")
			   И СтруктураЗначения.Свойство("ИдПолный") Тогда
				ПравилоЗагрузки = ПолучитьПравилоЗагрузкиТипа(СтруктураЗначения.Ссылка.Тип);
				Возврат Тип(СтрЗаменить(ПравилоЗагрузки.ТипЗначения, ".", "Объект."));
			КонецЕсли;
		КонецЕсли;
		Если СтруктураЗначения.Свойство("Типы")
		   И СтруктураЗначения.Свойство("КвалификаторыСтроки")
		   И СтруктураЗначения.Свойство("КвалификаторыЧисла")
		   И СтруктураЗначения.Свойство("КвалификаторыДаты") Тогда
			Если ТипЗнч(СтруктураЗначения.Типы) = Тип("Массив") Тогда
				Возврат Тип("ОписаниеТипов");
			КонецЕсли;
		КонецЕсли;
		Если СтруктураЗначения.Свойство("Строки") Тогда
			Если ТипЗнч(СтруктураЗначения.Строки) = Тип("Массив") Тогда
				Возврат Тип("ДеревоЗначений");
			КонецЕсли;
		КонецЕсли;
		Возврат Тип("Структура");
	Иначе
		Возврат ТипЗнч(СтруктураЗначения);
	КонецЕсли;
	
КонецФункции //СтруктураТипЗнч()

// Функция рекурсивно преобразует структуру значений в структуру с "простыми" типами
//
// Параметры:
//		Значение		- Структура		- Значение для преобразования
//
// Возвращаемое значение:
//   Структура			- Результат преобразования
//
Функция СтруктураВСтруктуру(Значение)
	
	Если НЕ (ТипЗнч(Значение) = Тип("Структура")
		  ИЛИ ТипЗнч(Значение) = Тип("ФиксированнаяСтруктура")) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ВремСтруктура = Новый Структура();
	Для Каждого ТекЭлемент Из Значение Цикл
		ВремСтруктура.Вставить(ТекЭлемент.Ключ, ЗначениеВСтруктуру(ТекЭлемент.Значение));
	КонецЦикла;
	
	Возврат ВремСтруктура;
	
КонецФункции //СтруктураВСтруктуру()

// Функция рекурсивно преобразует структуру с "простыми" типами значений в структуру значений 1С
//
// Параметры:
//		СтруктураЗначения		- Структура		- Значение для преобразования
//
// Возвращаемое значение:
//   Структура			- Результат преобразования
//
Функция СтруктураИзСтруктуры(СтруктураЗначения)
	
	Если НЕ ТипЗнч(СтруктураЗначения) = Тип("Структура") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ВремСтруктура = Новый Структура();
	
	Для Каждого ТекЭлемент Из СтруктураЗначения Цикл
		ВремСтруктура.Вставить(ТекЭлемент.Ключ, ЗначениеИзСтруктуры(ТекЭлемент.Значение));
	КонецЦикла;
	
	Возврат ВремСтруктура;
	
КонецФункции //СтруктураИзСтруктуры()

// Функция рекурсивно преобразует массив значений в массив с "простыми" типами
//
// Параметры:
//		Значение		- Массив		- Значение для преобразования
//
// Возвращаемое значение:
//   Массив			- Результат преобразования
//
Функция МассивВСтруктуру(Значение)
	
	Если НЕ (ТипЗнч(Значение) = Тип("Массив")
		  ИЛИ ТипЗнч(Значение) = Тип("ФиксированныйМассив")) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ВремМассив = Новый Массив();
	Для Каждого ТекЗначение Из Значение Цикл
		ВремМассив.Добавить(ЗначениеВСтруктуру(ТекЗначение));
	КонецЦикла;
	
	Возврат ВремМассив;
	
КонецФункции //МассивВСтруктуру()

// Функция рекурсивно преобразует массив с "простыми" типами значений в массив значений 1С
//
// Параметры:
//		СтруктураЗначения		- Массив		- Значение для преобразования
//
// Возвращаемое значение:
//   Массив			- Результат преобразования
//
Функция МассивИзСтруктуры(СтруктураЗначения)
	
	Если НЕ ТипЗнч(СтруктураЗначения) = Тип("Массив") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ВремМассив = Новый Массив();
	Для Каждого ТекЗначение Из СтруктураЗначения Цикл
		ВремМассив.Добавить(ЗначениеИзСтруктуры(ТекЗначение));
	КонецЦикла;
	
	Возврат ВремМассив;
	
КонецФункции //МассивИзСтруктуры()

// Функция рекурсивно преобразует соответствие значений в массив структур с "простыми" типами
//
// Параметры:
//		Значение		- Соответствие		- Значение для преобразования
//
// Возвращаемое значение:
//   Массив(Структура)			- Результат преобразования
//		Ключ						- Произвольный		- Ключ элемента соответствия
//		Значение					- Произвольный		- Значение элемента соответствия
//
Функция СоответствиеВСтруктуру(Значение)
	
	Если НЕ (ТипЗнч(Значение) = Тип("Соответствие")
	 ИЛИ ТипЗнч(Значение) = Тип("ФиксированноеСоответствие")) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ВремСоответствие = Новый Массив();
	
	Для Каждого ТекЭлемент Из Значение Цикл
		ВремСоответствие.Добавить(Новый Структура("Ключ,
												  |Значение",
												  ЗначениеВСтруктуру(ТекЭлемент.Ключ),
												  ЗначениеВСтруктуру(ТекЭлемент.Значение)));
	КонецЦикла;
	
	Возврат ВремСоответствие;
	
КонецФункции //СоответствиеВСтруктуру()

// Функция рекурсивно преобразует массив структур с "простыми" типами значений в соответствие значений 1С
//
// Параметры:
//		СтруктураЗначения		- Массив(Структура)		- Значение для преобразования
//			Ключ					- Произвольный			- Ключ элемента соответствия
//			Значение				- Произвольный			- Значение элемента соответствия
//
// Возвращаемое значение:
//   Соответствие			- Результат преобразования
//
Функция СоответствиеИзСтруктуры(СтруктураЗначения)
	
	Если НЕ ТипЗнч(СтруктураЗначения) = Тип("Массив") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если СтруктураЗначения.Количество() = 0 Тогда
		Возврат Новый Соответствие();
	КонецЕсли;
	
	Если СтруктураЗначения[0].Свойство("Ключ")  = Неопределено Тогда
		Возврат Новый Соответствие();
	КонецЕсли;
	
	ВремСоответствие = Новый Соответствие();
	
	Для Каждого ТекЭлемент Из СтруктураЗначения Цикл
		ВремСоответствие.Вставить(ЗначениеИзСтруктуры(ТекЭлемент.Ключ), ЗначениеИзСтруктуры(ТекЭлемент.Значение));
	КонецЦикла;
	
	Возврат ВремСоответствие;
	
КонецФункции //СоответствиеИзСтруктуры()

// Функция рекурсивно преобразует список значений в массив структур с "простыми" типами
//
// Параметры:
//		Значение		- СписокЗначений		- Значение для преобразования
//
// Возвращаемое значение:
//   Массив(Структура)			- Результат преобразования
//		Значение					- Произвольный		- Значение элемента списка значений
//		Представление				- Строка			- Представление элемента списка значений
//		Пометка						- Булево			- Пометка элемента списка значений
//
Функция СписокЗначенийВСтруктуру(Значение)
	
	Если НЕ ТипЗнч(Значение) = Тип("СписокЗначений") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ВремМассив = Новый Массив();
	Для Каждого ТекЭлемент Из Значение Цикл
		ВремЭлемент = Новый Структура("Значение, Представление, Пометка, Картинка"
									, ЗначениеВСтруктуру(ТекЭлемент.Значение)
									, ТекЭлемент.Представление
									, ТекЭлемент.Пометка
									, Неопределено);
		ВремМассив.Добавить(ВремЭлемент);
	КонецЦикла;
	
	Возврат ВремМассив;
	
КонецФункции //СписокЗначенийВСтруктуру()

// Функция рекурсивно преобразует массив структур с "простыми" типами значений в список значений 1С
//
// Параметры:
//		СтруктураЗначения		- Массив(Структура)		- Значение для преобразования
//			Значение				- Произвольный			- Значение элемента соответствия
//			Представление			- Строка				- Представление элемента списка значений
//			Пометка					- Булево				- Пометка элемента списка значений
//
// Возвращаемое значение:
//   СписокЗначений			- Результат преобразования
//
Функция СписокЗначенийИзСтруктуры(СтруктураЗначения)
	
	Если НЕ ТипЗнч(СтруктураЗначения) = Тип("Массив") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если СтруктураЗначения.Количество() = 0 Тогда
		Возврат Новый СписокЗначений();
	КонецЕсли;
	
	Если СтруктураЗначения[0].Свойство("Значение")  = Неопределено Тогда
		Возврат Новый СписокЗначений();
	КонецЕсли;
	
	ВремСписок = Новый СписокЗначений();
	Для Каждого ТекЭлемент Из СтруктураЗначения Цикл
		ВремСписок.Добавить(ЗначениеИзСтруктуры(ТекЭлемент.Значение), ТекЭлемент.Представление, ТекЭлемент.Пометка);
	КонецЦикла;
	
	Возврат ВремСписок;
	
КонецФункции //СписокЗначенийИзСтруктуры()

// Функция рекурсивно преобразует строку таблицы/дерева значений в структуру с "простыми" типами
//
// Параметры:
//		СтрокаЗначений	- СтрокаТаблицыЗначений		- Строка для преобразования
//						  СтрокаДереваЗначений
//		СписокСвойств	- Массив(Строка)			- Список заполняемых полей строки
//
// Возвращаемое значение:
//   Структура			- Результат преобразования
//		<Имя колонки>			- Произвольный		- Значение поля строки таблицы/дерева
//
Функция СтрокаЗначенийВСтруктуру(СтрокаЗначений, СписокСвойств)
	
	ВремСтрока = Новый Структура();
	
	Для Каждого ТекСвойство Из СписокСвойств Цикл
		ВремСтрока.Вставить(ТекСвойство, ЗначениеВСтруктуру(СтрокаЗначений[ТекСвойство]));
	КонецЦикла;
	
	Возврат ВремСтрока;
	
КонецФункции //СтрокаЗначенийВСтруктуру()

// Процедура рекурсивно заполняет строку таблицы/дерева значений данными из структуры с "простыми" типами значений
//
// Параметры:
//		СтрокаЗначений		- СтрокаТаблицыЗначений		- Строка для преобразования
//							  СтрокаДереваЗначений
//		СтруктураЗначений	- Структура					- Значение для преобразования
//			<Имя колонки>		- Произвольный				- Значение поля строки таблицы/дерева
//		СписокСвойств		- Массив(Строка)			- Список заполняемых полей строки
//
Процедура СтрокаЗначенийИзСтруктуры(СтрокаЗначений, СтруктураЗначений, СписокСвойств)
	
	Для Каждого ТекСвойство Из СписокСвойств Цикл
		СтрокаЗначений[ТекСвойство] = ЗначениеИзСтруктуры(СтруктураЗначений[ТекСвойство]);
	КонецЦикла;
	
КонецПроцедуры //СтрокаЗначенийИзСтруктуры()

// Функция рекурсивно преобразует таблицу значений в массив структур с "простыми" типами
//
// Параметры:
//		Значение		- ТаблицаЗначений		- Значение для преобразования
//
// Возвращаемое значение:
//   Массив(Структура)			- Результат преобразования
//		<Имя колонки>				- Произвольный		- Значение поля строки таблицы значений
//
Функция ТаблицаЗначенийВСтруктуру(Значение, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено)
	
	Если НЕ ТипЗнч(Значение) = Тип("ТаблицаЗначений") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ВремТаб = Новый Массив();
	
	МассивКолонок = Новый Массив();
	Для Каждого ТекКолонка Из Значение.Колонки Цикл
		Если НЕ ИспользоватьСвойство(ТекКолонка.Имя, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;
		МассивКолонок.Добавить(ТекКолонка.Имя);
	КонецЦикла;
	
	Для Каждого ТекСтрока Из Значение Цикл
		ВремТаб.Добавить(СтрокаЗначенийВСтруктуру(ТекСтрока, МассивКолонок));
	КонецЦикла;
	
	Возврат ВремТаб;
	
КонецФункции //ТаблицаЗначенийВСтруктуру()

// Функция рекурсивно преобразует массив структур с "простыми" типами значений в таблицу значений 1С
//
// Параметры:
//		СтруктураЗначения		- Массив(Структура)		- Значение для преобразования
//			<Имя колонки>			- Произвольный			- Значение поля строки таблицы значений
//
// Возвращаемое значение:
//   ТаблицаЗначений			- Результат преобразования
//
Функция ТаблицаЗначенийИзСтруктуры(СтруктураЗначения, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено)
	
	Если НЕ ТипЗнч(СтруктураЗначения) = Тип("Массив") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если СтруктураЗначения.Количество() = 0 Тогда
		Возврат Новый ТаблицаЗначений();
	КонецЕсли;
	
	ВремТаб = Новый ТаблицаЗначений();
	МассивКолонок = Новый Массив();
	
	Для Каждого ТекЭлемент Из СтруктураЗначения[0] Цикл
		Если НЕ ИспользоватьСвойство(ТекЭлемент.Ключ, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;
		ВремТаб.Колонки.Добавить(ТекЭлемент.Ключ);
		МассивКолонок.Добавить(ТекЭлемент.Ключ);
	КонецЦикла;
	
	Для Каждого ТекСтрока Из СтруктураЗначения Цикл
		НоваяСтрока = ВремТаб.Добавить();
		СтрокаЗначенийИзСтруктуры(НоваяСтрока, ТекСтрока, МассивКолонок);
	КонецЦикла;
	
	Возврат ВремТаб;
	
КонецФункции //ТаблицаЗначенийИзСтруктуры()

// Функция рекурсивно преобразует строки дерева значений в массив структур с "простыми" типами
//
// Параметры:
//		СтрокиДерева	- КоллекцияСтрокДереваЗначений		- Строки для преобразования
//		СписокСвойств	- Массив(Строка)					- Список заполняемых полей строки
//
// Возвращаемое значение:
//   Массив(Структура)		- Результат преобразования
//		<Имя колонки>			- Произвольный		- Значение поля строки дерева
//
Функция СтрокиДереваВСтруктуру(СтрокиДерева, СписокСвойств)
	
	ВремСтроки = Новый Массив();
	
	Для Каждого ТекСтрока Из СтрокиДерева Цикл
		ВремСтрока = СтрокаЗначенийВСтруктуру(ТекСтрока, СписокСвойств);
		ВремСтрока.Вставить("Строки", СтрокиДереваВСтруктуру(ТекСтрока.Строки, СписокСвойств));
		ВремСтроки.Добавить(ВремСТрока);
	КонецЦикла;
	
	Возврат ВремСтроки;
	
КонецФункции //СтрокиДереваВСтруктуру()

// Процедура рекурсивно заполняет строки дерева значений данными из массива структур с "простыми" типами значений
//
// Параметры:
//		СтрокиДерева		- КоллекцияСтрокДереваЗначений		- Строка для преобразования
//		СтруктураСтрок		- Массив(Структура)					- Значение для преобразования
//			<Имя колонки>		- Произвольный						- Значение поля строки дерева
//		СписокСвойств		- Массив(Строка)					- Список заполняемых полей строк
//
Процедура СтрокиДереваИзСтруктуры(СтрокиДерева, СтруктураСтрок, СписокСвойств)
	
	Для Каждого ТекСтрока Из СтруктураСтрок Цикл
		НоваяСтрока = СтрокиДерева.Добавить();
		СтрокаЗначенийИзСтруктуры(НоваяСтрока, ТекСтрока, СписокСвойств);
		СтрокиДереваИзСтруктуры(НоваяСтрока.Строки, ТекСтрока.Строки, СписокСвойств);
	КонецЦикла;
	
КонецПроцедуры //СтрокиДереваИзСтруктуры()

// Функция рекурсивно преобразует дерево значений в структуру с "простыми" типами
//
// Параметры:
//		Значение		- ДеревоЗначений		- Значение для преобразования
//
// Возвращаемое значение:
//   Структура			- Результат преобразования
//		Строки				- Массив(Структура)	- Строки дерева значений
//			<Имя колонки>		- Произвольный		- Значение поля строки дерева значений
//
Функция ДеревоЗначенийВСтруктуру(Значение, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено)
	
	Если НЕ ТипЗнч(Значение) = Тип("ДеревоЗначений") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивКолонок = Новый Массив();
	Для Каждого ТекКолонка Из Значение.Колонки Цикл
		Если НЕ ИспользоватьСвойство(ТекКолонка.Имя, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;
		МассивКолонок.Добавить(ТекКолонка.Имя);
	КонецЦикла;
	
	ВремДерево = Новый Структура("Строки", СтрокиДереваВСтруктуру(Значение.Строки, МассивКолонок));
	
	Возврат ВремДерево;
	
КонецФункции //ДеревоЗначенийВСтруктуру()

// Функция рекурсивно преобразует структуру с "простыми" типами значений в дерево значений 1С
//
// Параметры:
//		СтруктураЗначения		- Структура				- Значение для преобразования
//			Строки					- Массив(Структура)		- Строки дерева значений
//				<Имя колонки>			- Произвольный			- Значение поля строки дерева значений
//
// Возвращаемое значение:
//   ДеревоЗначений			- Результат преобразования
//
Функция ДеревоЗначенийИзСтруктуры(СтруктураЗначения, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено)
	
	Если НЕ ТипЗнч(СтруктураЗначения) = Тип("Структура") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если НЕ СтруктураЗначения.Свойство("Строки") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если НЕ ТипЗнч(СтруктураЗначения.Строки) = Тип("Массив") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если СтруктураЗначения.Строки.Количество() = 0 Тогда
		Возврат Новый ДеревоЗначений();
	КонецЕсли;
	
	ВремДерево = Новый ДеревоЗначений();
	
	МассивКолонок = Новый Массив();
	
	Для Каждого ТекЭлемент Из СтруктураЗначения.Строки[0] Цикл
		Если ТекЭлемент.Ключ = "Строки" Тогда
			Продолжить;
		КонецЕсли;
		Если НЕ ИспользоватьСвойство(ТекЭлемент.Ключ, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;
		ВремДерево.Колонки.Добавить(ТекЭлемент.Ключ);
		МассивКолонок.Добавить(ТекЭлемент.Ключ);
	КонецЦикла;
	
	СтрокиДереваИзСтруктуры(ВремДерево.Строки, СтруктураЗначения.Строки, МассивКолонок);
	
	Возврат ВремДерево;
	
КонецФункции //ДеревоЗначенийИзСтруктуры()

#КонецОбласти

#Область ПреобразованияОбъектовОбщие

// Преобразует значение ссылочного типа в структуру
//
// Параметры:
//  Объект				- Объект, ЛюбаяСсылка		- Преобразуемый объект
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Ссылка			- Структура		- Описание ссылки на объект
//			Тип 						- Строка		- Текстовое описание типа объекта
//			Ид                          - Строка		- Уникальный идентификатор ссылки
//			ИдПолный					- Строка		- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево		- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка		- Имя предопределенного значения
//			Представление				- Строка		- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный	- Дополнительные поля добавленные при выгрузке
//		__ТЧ			- Массив		- Массив табличных частей объекта
//		<имя поля>						- Произвольный	- Значения реквизитов объекта
//
Функция ОбъектВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТипЗнч(Объект));
	
	Если ОписаниеВида = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтруктураОбъекта = Неопределено;
	
	Если ВРег(ОписаниеВида.Имя) = ВРег("Справочник") Тогда
		СтруктураОбъекта = СправочникВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("Документ") Тогда
		СтруктураОбъекта = ДокументВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("ПланВидовХарактеристик") Тогда
		СтруктураОбъекта = ПланВидовХарактеристикВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("ПланСчетов") Тогда
		СтруктураОбъекта = ПланСчетовВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("ПланВидовРасчета") Тогда
		СтруктураОбъекта = ПланВидовРасчетаВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("ПланОбмена") Тогда
		СтруктураОбъекта = ПланОбменаВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("БизнесПроцесс") Тогда
		СтруктураОбъекта = БизнесПроцессВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("Задача") Тогда
		СтруктураОбъекта = ЗадачаВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Возврат СтруктураОбъекта;
	
КонецФункции //ОбъектВСтруктуру()

// Заполняет объект (ссылочного типа) из структуры
//
// Параметры:
//  Объект				- Объект					- Заполняемый объект
//  СтруктураОбъекта	- Структура					- Данные для заполнения объекта
//		Ссылка					- Структура				- Описание ссылки на объект
//			Тип 						- Строка			- Текстовое описание типа объекта
//			Ид                          - Строка			- Уникальный идентификатор ссылки
//			ИдПолный					- Строка			- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево			- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка			- Имя предопределенного значения
//			Представление				- Строка			- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный		- Дополнительные поля добавленные при выгрузке
//		__ТЧ					- Массив				- Массив табличных частей объекта
//		<имя поля>				- Произвольный			- Значения реквизитов объекта
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ЗаполнитьОбъектИзСтруктуры(Объект, СтруктураОбъекта, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	Попытка
		ОписаниеВида = ПолучитьОписаниеВидаОбъектов(СтруктураОбъекта.Ссылка.Тип);
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		Возврат;
	КонецПопытки;
	
	Если ВРег(ОписаниеВида.Имя) = ВРег("Справочник") Тогда
		СправочникИзСтруктуры(Объект, СтруктураОбъекта, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("Документ") Тогда
		ДокументИзСтруктуры(Объект, СтруктураОбъекта, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("ПланВидовХарактеристик") Тогда
		ПланВидовХарактеристикИзСтруктуры(Объект, СтруктураОбъекта, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("ПланСчетов") Тогда
		ПланСчетовИзСтруктуры(Объект, СтруктураОбъекта, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("ПланВидовРасчета") Тогда
		ПланВидовРасчетаИзСтруктуры(Объект, СтруктураОбъекта, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("ПланОбмена") Тогда
		ПланОбменаИзСтруктуры(Объект, СтруктураОбъекта, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("БизнесПроцесс") Тогда
		БизнесПроцессИзСтруктуры(Объект, СтруктураОбъекта, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("Задача") Тогда
		ЗадачаИзСтруктуры(Объект, СтруктураОбъекта, СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
КонецПроцедуры //ЗаполнитьОбъектИзСтруктуры()

// Создает объект (ссылочного типа) из структуры
//
// Параметры:
//  Объект				- Объект					- Заполняемый объект
//  СтруктураОбъекта	- Структура					- Данные для заполнения объекта
//		Ссылка					- Структура				- Описание ссылки на объект
//			Тип 						- Строка			- Текстовое описание типа объекта
//			Ид                          - Строка			- Уникальный идентификатор ссылки
//			ИдПолный					- Строка			- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево			- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка			- Имя предопределенного значения
//			Представление				- Строка			- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный		- Дополнительные поля добавленные при выгрузке
//		__ТЧ					- Массив				- Массив табличных частей объекта
//		<имя поля>				- Произвольный			- Значения реквизитов объекта
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Объект				- созданный объект
//
Функция СоздатьОбъектИзСтруктуры(СтруктураОбъекта, УстановитьСсылку = Ложь, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	Попытка
		ОписаниеВида = ПолучитьОписаниеВидаОбъектов(СтруктураОбъекта.Ссылка.Тип);
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		Возврат Неопределено;
	КонецПопытки;
	
	МетаОбъект = Метаданные.НайтиПоПолномуИмени(СтруктураОбъекта.Ссылка.Тип);
	Менеджер = ОписаниеВида.Коллекция[МетаОбъект.Имя];
	Конструктор = ОписаниеВида.Конструктор;
	
	Если ВРег(ОписаниеВида.Имя) = ВРег("Справочник") Тогда
		Если ОписаниеВида.МетаКоллекция[МетаОбъект.Имя].Иерархический
		   И ОписаниеВида.МетаКоллекция[МетаОбъект.Имя].ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов Тогда
			Если СтруктураОбъекта.ЭтоГруппа Тогда 
				Конструктор = ОписаниеВида.КонструкторАльт;
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("ПланВидовХарактеристик") Тогда
		Если ОписаниеВида.МетаКоллекция[МетаОбъект.Имя].Иерархический Тогда
			Если СтруктураОбъекта.ЭтоГруппа Тогда 
				Конструктор = ОписаниеВида.КонструкторАльт;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Объект = Неопределено;
	
	Если ЗначениеЗаполнено(Конструктор) Тогда
		
		Объект = Вычислить("Менеджер." + Конструктор + "()");
		
		Если УстановитьСсылку Тогда
			Объект.УстановитьСсылкуНового(Менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(СтруктураОбъекта.Ссылка.Ид)));
		КонецЕсли;
		
		ЗаполнитьОбъектИзСтруктуры(Объект, СтруктураОбъекта, СписокСвойств, ИсключаяСвойства);
		
	КонецЕсли;
	
	Возврат Объект;
	
КонецФункции //СоздатьОбъектИзСтруктуры()

// Преобразует набор записей регистра, полученный по указанному отбору, в структуру
//
// Параметры:
//  Регистр				- Строка					- Строковое представление типа регистра (например: РегистрСведений.КурсыВалют)
//  Отбор				- Структура					- Структура вида <Имя поля>: <Значение поля>, значения полей отбора
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Отбор			- Структура				- Описание отбора записей регистра
//			<имя поля>		- Произвольный			- Значение отбора
//		Записи			- Массив(Структура)		- Массив записей регистра
//			<имя поля>		- Произвольный			- Значения измерений, ресурсов и реквизитов записи регистра
//
Функция РегистрПоОтборуВСтруктуру(Регистр, Отбор, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(Регистр);
	
	Если ОписаниеВида = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МетаОбъект = Метаданные.НайтиПоПолномуИмени(Регистр);
	
	НаборЗаписей = ОписаниеВида.Коллекция[МетаОбъект.Имя].СоздатьНаборЗаписей();
	Для Каждого ТекЭлемент Из Отбор Цикл
		НаборЗаписей.Отбор[ТекЭлемент.Ключ].Установить(ТекЭлемент.Значение);
	КонецЦикла;
	НаборЗаписей.Прочитать();
	
	СтруктураОбъекта = Неопределено;
	
	Если ВРег(ОписаниеВида.Имя) = ВРег("РегистрСведений") Тогда
		СтруктураОбъекта = НаборЗаписейРегистраСведенийВСтруктуру(НаборЗаписей, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("РегистрНакопления") Тогда
		СтруктураОбъекта = НаборЗаписейРегистраНакопленияВСтруктуру(НаборЗаписей, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("РегистрБухгалтерии") Тогда
		СтруктураОбъекта = НаборЗаписейРегистраБухгалтерииВСтруктуру(НаборЗаписей, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("РегистрРасчета") Тогда
		СтруктураОбъекта = НаборЗаписейРегистраРасчетаВСтруктуру(НаборЗаписей, СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Возврат СтруктураОбъекта;
	
КонецФункции //РегистрПоОтборуВСтруктуру()

// Преобразует движения документа в структуру
//
// Параметры:
//  Объект				- ДокументСсылка			- Документ, для которого получаются движения
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- движения документа по регистрам
//		<Имя регистра>			- Структура				- Движения регистра
//			Отбор					- Структура				- Описание отбора записей регистра
//				<имя поля>				- Произвольный			- Значение отбора
//			Записи				- Массив(Структура)		- Массив записей регистра
//				<имя поля>			- Произвольный			- Значения измерений, ресурсов и реквизитов записи регистра
//
Функция ДвиженияДокументаВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено)
	
	МетаОбъект = Объект.Метаданные();
	
	Отбор = Новый Структура("Регистратор", Объект.Ссылка);
	
	СтруктураДвижений = Новый Структура();
	Для Каждого ТекДвижения Из МетаОбъект.Движения Цикл
		Если НЕ ИспользоватьСвойство("Движения." + ТекДвижения.ПолноеИмя(), СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;
		
		СтруктураДвижений.Вставить(ТекДвижения.Имя, РегистрПоОтборуВСтруктуру(ТекДвижения.ПолноеИмя(), Отбор, СписокСвойств, ИсключаяСвойства));
	КонецЦикла;
	
	Возврат СтруктураДвижений;
	
КонецФункции //ДвиженияДокументаВСтруктуру()

// Заполняет движения документа из структуры
//
// Параметры:
//  Объект				- ДокументОбъект			- Документ, для которого заполняются движения
//  СтруктураДвижений	- Структура					- Движения документа по регистрам
//		<Имя регистра>		- Структура				- Движения регистра
//			Отбор				- Структура				- Описание отбора записей регистра
//				<имя поля>			- Произвольный			- Значение отбора
//			Записи			- Массив(Структура)		- Массив записей регистра
//				<имя поля>		- Произвольный			- Значения измерений, ресурсов и реквизитов записи регистра
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//
Процедура ДвиженияДокументаИзСтруктуры(Объект, СтруктураДвижений, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено)

	МетаОбъект = Объект.Метаданные();
	
	Для Каждого ТекДвижения Из МетаОбъект.Движения Цикл
		Если НЕ ИспользоватьСвойство("Движения." + ТекДвижения.ПолноеИмя(), СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;
		
		ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТекДвижения.ПолноеИмя());
		
		Если ВРег(ОписаниеВида.Имя) = ВРег("РегистрСведений") Тогда
			НаборЗаписейРегистраСведенийИзСтруктуры(Объект.Движения[ТекДвижения.Имя], СтруктураДвижений[ТекДвижения.Имя], СписокСвойств, ИсключаяСвойства);
		ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("РегистрНакопления") Тогда
			НаборЗаписейРегистраНакопленияИзСтруктуры(Объект.Движения[ТекДвижения.Имя], СтруктураДвижений[ТекДвижения.Имя], СписокСвойств, ИсключаяСвойства);
		ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("РегистрБухгалтерии") Тогда
			НаборЗаписейРегистраБухгалтерииИзСтруктуры(Объект.Движения[ТекДвижения.Имя], СтруктураДвижений[ТекДвижения.Имя], СписокСвойств, ИсключаяСвойства);
		ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("РегистрРасчета") Тогда
			НаборЗаписейРегистраРасчетаИзСтруктуры(Объект.Движения[ТекДвижения.Имя], СтруктураДвижений[ТекДвижения.Имя], СписокСвойств, ИсключаяСвойства);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры //ДвиженияДокументаИзСтруктуры()

#КонецОбласти

#Область ПреобразованияОбъектовПоВидам

// Преобразует элемент справочника в структуру
//
// Параметры:
//  Объект				- Объект, ЛюбаяСсылка		- Преобразуемый объект
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Ссылка			- Структура		- Описание ссылки на объект
//			Тип 						- Строка		- Текстовое описание типа объекта
//			Ид                          - Строка		- Уникальный идентификатор ссылки
//			ИдПолный					- Строка		- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево		- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка		- Имя предопределенного значения
//			Представление				- Строка		- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный	- Дополнительные поля добавленные при выгрузке
//		__ТЧ			- Массив		- Массив табличных частей объекта
//		<имя поля>						- Произвольный	- Значения реквизитов объекта
//
Функция СправочникВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = Объект.Метаданные();
	
	СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект));
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ЭтоГруппа", СписокСвойств, ИсключаяСвойства);
	
	СтруктураОбъекта.Вставить("Родитель", Неопределено);
	Если МетаОбъект.Иерархический Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Родитель", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
			
	СтруктураОбъекта.Вставить("Владелец", Неопределено);
	Если МетаОбъект.Владельцы.Количество() > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Владелец", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	СтруктураОбъекта.Вставить("Код", Неопределено);
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Код", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	СтруктураОбъекта.Вставить("Наименование", Неопределено);
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		Если МетаОбъект.Иерархический И МетаОбъект.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов Тогда
			Если (Объект.ЭтоГруппа И ТекРеквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента)
			 ИЛИ (НЕ Объект.ЭтоГруппа И ТекРеквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы)Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		Если МетаОбъект.Иерархический И МетаОбъект.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов Тогда
			Если (Объект.ЭтоГруппа И ТекТЧ.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента)
			 ИЛИ (НЕ Объект.ЭтоГруппа И ТекТЧ.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы)Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Возврат СтруктураОбъекта;
	
КонецФункции //СправочникВСтруктуру()

// Заполняет справочник из структуры
//
// Параметры:
//  Объект				- Объект					- Заполняемый объект
//  СтруктураОбъекта	- Структура					- Данные для заполнения объекта
//		Ссылка					- Структура				- Описание ссылки на объект
//			Тип 						- Строка			- Текстовое описание типа объекта
//			Ид                          - Строка			- Уникальный идентификатор ссылки
//			ИдПолный					- Строка			- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево			- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка			- Имя предопределенного значения
//			Представление				- Строка			- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный		- Дополнительные поля добавленные при выгрузке
//		__ТЧ					- Массив				- Массив табличных частей объекта
//		<имя поля>				- Произвольный			- Значения реквизитов объекта
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура СправочникИзСтруктуры(Объект, СтруктураОбъекта, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = Объект.Метаданные();
	
	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	
	Если МетаОбъект.Иерархический Тогда
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Родитель", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
			
	Если МетаОбъект.Владельцы.Количество() > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Владелец", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Код", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		Если МетаОбъект.Иерархический И МетаОбъект.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов Тогда
			Если (Объект.ЭтоГруппа И ТекРеквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента)
			 ИЛИ (НЕ Объект.ЭтоГруппа И ТекРеквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы)Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		Если МетаОбъект.Иерархический И МетаОбъект.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов Тогда
			Если (Объект.ЭтоГруппа И ТекТЧ.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента)
			 ИЛИ (НЕ Объект.ЭтоГруппа И ТекТЧ.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы)Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		ТЧОбъектаИзСтруктуры(Объект, СтруктураОбъекта, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
КонецПроцедуры //СправочникИзСтруктуры()

// Преобразует счет в структуру
//
// Параметры:
//  Объект				- Объект, ЛюбаяСсылка		- Преобразуемый объект
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Ссылка			- Структура		- Описание ссылки на объект
//			Тип 						- Строка		- Текстовое описание типа объекта
//			Ид                          - Строка		- Уникальный идентификатор ссылки
//			ИдПолный					- Строка		- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево		- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка		- Имя предопределенного значения
//			Представление				- Строка		- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный	- Дополнительные поля добавленные при выгрузке
//		__ТЧ			- Массив		- Массив табличных частей объекта
//		<имя поля>						- Произвольный	- Значения реквизитов объекта
//
Функция ПланСчетовВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = Объект.Метаданные();
	
	СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект));
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Забалансовый", СписокСвойств, ИсключаяСвойства);
	
	Если ИспользоватьСвойство("Вид", СписокСвойств, ИсключаяСвойства) Тогда
		СтруктураОбъекта.Вставить("Вид", ?(Объект.Вид = ВидСчета.Активный, "Активный",
										   ?(Объект.Вид = ВидСчета.Пассивный, "Пассивный",
											 "АктивноПассивный")));
	КонецЕсли;
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Родитель", СписокСвойств, ИсключаяСвойства);
			
	СтруктураОбъекта.Вставить("Код", Неопределено);
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Код", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	СтруктураОбъекта.Вставить("Порядок", Неопределено);
	Если МетаОбъект.ДлинаПорядка > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Порядок", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	СтруктураОбъекта.Вставить("Наименование", Неопределено);
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Для Каждого ТекПризнак Из МетаОбъект.ПризнакиУчета Цикл
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекПризнак.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	СтруктураОбъекта.Вставить("ВидыСубконто", Новый Массив());
	Если ИспользоватьСвойство("ВидыСубконто", СписокСвойств, ИсключаяСвойства) Тогда
		й = 1;
		Для Каждого ТекСтрока Из Объект.ВидыСубконто Цикл
			СтрокаСубконто = Новый Структура("НомерСтроки, ВидСубконто, ТолькоОбороты"
											, й
											, ЗначениеВСтруктуру(ТекСтрока.ВидСубконто)
											, ТекСтрока.ТолькоОбороты);
			
			Для Каждого ТекПризнак Из МетаОбъект.ПризнакиУчетаСубконто Цикл
				СтрокаСубконто.Вставить(ТекПризнак.Имя, ТекСтрока[ТекПризнак.Имя]);
			КонецЦикла;
			СтруктураОбъекта.ВидыСубконто.Добавить(СтрокаСубконто);
			й = й + 1;
		КонецЦикла;
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Возврат СтруктураОбъекта;
	
КонецФункции //ПланСчетовВСтруктуру()

// Заполняет счет из структуры
//
// Параметры:
//  Объект				- Объект					- Заполняемый объект
//  СтруктураОбъекта	- Структура					- Данные для заполнения объекта
//		Ссылка					- Структура				- Описание ссылки на объект
//			Тип 						- Строка			- Текстовое описание типа объекта
//			Ид                          - Строка			- Уникальный идентификатор ссылки
//			ИдПолный					- Строка			- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево			- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка			- Имя предопределенного значения
//			Представление				- Строка			- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный		- Дополнительные поля добавленные при выгрузке
//		__ТЧ					- Массив				- Массив табличных частей объекта
//		<имя поля>				- Произвольный			- Значения реквизитов объекта
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ПланСчетовИзСтруктуры(Объект, СтруктураОбъекта, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = Объект.Метаданные();
	
	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Забалансовый", СписокСвойств, ИсключаяСвойства);
	Если ИспользоватьСвойство("Вид", СписокСвойств, ИсключаяСвойства) Тогда
		Объект.Вид = Вычислить("ВидСчета." + СтруктураОбъекта.Вид);
	КонецЕсли;
	
	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Родитель", СписокСвойств, ИсключаяСвойства);
			
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Код", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Если МетаОбъект.ДлинаПорядка > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Порядок", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Для Каждого ТекПризнак Из МетаОбъект.ПризнакиУчета Цикл
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, ТекПризнак.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Если СтруктураОбъекта.Свойство("ВидыСубконто") И ИспользоватьСвойство("ВидыСубконто", СписокСвойств, ИсключаяСвойства) Тогда
		Объект.ВидыСубконто.Очистить();
		Для Каждого ТекСтрока Из СтруктураОбъекта.ВидыСубконто Цикл
			Если Объект.ВидыСубконто.Количество() >= МетаОбъект.МаксКоличествоСубконто Тогда
				Прервать;
			КонецЕсли;
			НоваяСтрока = Объект.ВидыСубконто.Добавить();
			НоваяСтрока.ВидСубконто		= ЗначениеИзСтруктуры(ТекСтрока.ВидСубконто);
			НоваяСтрока.ТолькоОбороты	= ТекСтрока.ТолькоОбороты;
			
			Для Каждого ТекПризнак Из МетаОбъект.ПризнакиУчетаСубконто Цикл
				Если НЕ ТекСтрока.Свойство(ТекПризнак.Имя) Тогда
					Продолжить;
				КонецЕсли;
				НоваяСтрока[ТекПризнак.Имя] = ТекСтрока[ТекПризнак.Имя];
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаИзСтруктуры(Объект, СтруктураОбъекта, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
КонецПроцедуры //ПланСчетовИзСтруктуры()

// Преобразует элемент плана видов характеристик в структуру
//
// Параметры:
//  Объект				- Объект, ЛюбаяСсылка		- Преобразуемый объект
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Ссылка			- Структура		- Описание ссылки на объект
//			Тип 						- Строка		- Текстовое описание типа объекта
//			Ид                          - Строка		- Уникальный идентификатор ссылки
//			ИдПолный					- Строка		- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево		- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка		- Имя предопределенного значения
//			Представление				- Строка		- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный	- Дополнительные поля добавленные при выгрузке
//		__ТЧ			- Массив		- Массив табличных частей объекта
//		<имя поля>						- Произвольный	- Значения реквизитов объекта
//
Функция ПланВидовХарактеристикВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = Объект.Метаданные();
	
	СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект));
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ЭтоГруппа", СписокСвойств, ИсключаяСвойства);
	
	СтруктураОбъекта.Вставить("Родитель", Неопределено);
	Если МетаОбъект.Иерархический Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Родитель", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
			
	СтруктураОбъекта.Вставить("Код", Неопределено);
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Код", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	СтруктураОбъекта.Вставить("Наименование", Неопределено);
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	СтруктураОбъекта.Вставить("ТипЗначения", ОписаниеТиповВСтруктуру(Объект.ТипЗначения));

	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		Если МетаОбъект.Иерархический Тогда
			Если (Объект.ЭтоГруппа И ТекРеквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента)
			 ИЛИ (НЕ Объект.ЭтоГруппа И ТекРеквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы)Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		Если МетаОбъект.Иерархический Тогда
			Если (Объект.ЭтоГруппа И ТекТЧ.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента)
			 ИЛИ (НЕ Объект.ЭтоГруппа И ТекТЧ.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы)Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Возврат СтруктураОбъекта;
	
КонецФункции //ПланВидовХарактеристикВСтруктуру()

// Заполняет элемент плана вида характеристик из структуры
//
// Параметры:
//  Объект				- Объект					- Заполняемый объект
//  СтруктураОбъекта	- Структура					- Данные для заполнения объекта
//		Ссылка					- Структура				- Описание ссылки на объект
//			Тип 						- Строка			- Текстовое описание типа объекта
//			Ид                          - Строка			- Уникальный идентификатор ссылки
//			ИдПолный					- Строка			- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево			- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка			- Имя предопределенного значения
//			Представление				- Строка			- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный		- Дополнительные поля добавленные при выгрузке
//		__ТЧ					- Массив				- Массив табличных частей объекта
//		<имя поля>				- Произвольный			- Значения реквизитов объекта
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ПланВидовХарактеристикИзСтруктуры(Объект, СтруктураОбъекта, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = Объект.Метаданные();
	
	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	
	Если МетаОбъект.Иерархический Тогда
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Родитель", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
			
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Код", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Если СтруктураОбъекта.ТипЗначения.Типы.Количество() > 0 Тогда
		Объект.ТипЗначения = ОписаниеТиповИзСтруктуры(СтруктураОбъекта.ТипЗначения);
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		Если МетаОбъект.Иерархический Тогда
			Если (Объект.ЭтоГруппа И ТекРеквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента)
			 ИЛИ (НЕ Объект.ЭтоГруппа И ТекРеквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы)Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		Если МетаОбъект.Иерархический Тогда
			Если (Объект.ЭтоГруппа И ТекТЧ.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента)
			 ИЛИ (НЕ Объект.ЭтоГруппа И ТекТЧ.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы)Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		ТЧОбъектаИзСтруктуры(Объект, СтруктураОбъекта, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
КонецПроцедуры //ПланВидовХарактеристикИзСтруктуры()

// Преобразует вид расчета в структуру
//
// Параметры:
//  Объект				- Объект, ЛюбаяСсылка		- Преобразуемый объект
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Ссылка			- Структура		- Описание ссылки на объект
//			Тип 						- Строка		- Текстовое описание типа объекта
//			Ид                          - Строка		- Уникальный идентификатор ссылки
//			ИдПолный					- Строка		- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево		- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка		- Имя предопределенного значения
//			Представление				- Строка		- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный	- Дополнительные поля добавленные при выгрузке
//		__ТЧ			- Массив		- Массив табличных частей объекта
//		<имя поля>						- Произвольный	- Значения реквизитов объекта
//
Функция ПланВидовРасчетаВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = Объект.Метаданные();
	
	СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект));
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	
	СтруктураОбъекта.Вставить("БазовыеВидыРасчета", Новый Массив());
	Если НЕ МетаОбъект.ЗависимостьОтВидовРасчета = Метаданные.СвойстваОбъектов.ИспользованиеБазыПланаВидовРасчета.НеИспользовать
	   И ИспользоватьСвойство("БазовыеВидыРасчета", СписокСвойств, ИсключаяСвойства) Тогда
		Для Каждого ТекВР Из Объект.БазовыеВидыРасчета Цикл
			СтруктураОбъекта.БазовыеВидыРасчета.Добавить(ЗначениеВСтруктуру(ТекВР.ВидРасчета));
		КонецЦикла;
	КонецЕсли;
	
	СтруктураОбъекта.Вставить("ВедущиеВидыРасчета", Новый Массив());
	Если ИспользоватьСвойство("ВедущиеВидыРасчета", СписокСвойств, ИсключаяСвойства) Тогда
		Для Каждого ТекВР Из Объект.ВедущиеВидыРасчета Цикл
			СтруктураОбъекта.ВедущиеВидыРасчета.Добавить(ЗначениеВСтруктуру(ТекВР.ВидРасчета));
		КонецЦикла;
	КонецЕсли;
	
	СтруктураОбъекта.Вставить("ВытесняющиеВидыРасчета", Новый Массив());
	Если МетаОбъект.ИспользованиеПериодаДействия
	   И ИспользоватьСвойство("ВытесняющиеВидыРасчета", СписокСвойств, ИсключаяСвойства) Тогда
		Для Каждого ТекВР Из Объект.ВытесняющиеВидыРасчета Цикл
			СтруктураОбъекта.ВытесняющиеВидыРасчета.Добавить(ЗначениеВСтруктуру(ТекВР.ВидРасчета));
		КонецЦикла;
	КонецЕсли;
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПериодДействияБазовый", СписокСвойств, ИсключаяСвойства);
	
	СтруктураОбъекта.Вставить("Код", Неопределено);
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Код", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	СтруктураОбъекта.Вставить("Наименование", Неопределено);
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Возврат СтруктураОбъекта;
	
КонецФункции //ПланВидовРасчетаВСтруктуру()

// Заполняет вид расчета из структуры
//
// Параметры:
//  Объект				- Объект					- Заполняемый объект
//  СтруктураОбъекта	- Структура					- Данные для заполнения объекта
//		Ссылка					- Структура				- Описание ссылки на объект
//			Тип 						- Строка			- Текстовое описание типа объекта
//			Ид                          - Строка			- Уникальный идентификатор ссылки
//			ИдПолный					- Строка			- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево			- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка			- Имя предопределенного значения
//			Представление				- Строка			- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный		- Дополнительные поля добавленные при выгрузке
//		__ТЧ					- Массив				- Массив табличных частей объекта
//		<имя поля>				- Произвольный			- Значения реквизитов объекта
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ПланВидовРасчетаИзСтруктуры(Объект, СтруктураОбъекта, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = Объект.Метаданные();
	
	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	
	Если НЕ МетаОбъект.ЗависимостьОтВидовРасчета = Метаданные.СвойстваОбъектов.ИспользованиеБазыПланаВидовРасчета.НеИспользовать
	   И ИспользоватьСвойство("БазовыеВидыРасчета", СписокСвойств, ИсключаяСвойства) Тогда
		Объект.БазовыеВидыРасчета.Очистить();
		Для Каждого ТекВР Из СтруктураОбъекта.БазовыеВидыРасчета Цикл
			ВремВР = ЗначениеИзСтруктуры(ТекВР);
			Если НЕ ЗначениеЗаполнено(ВремВР) Тогда
				Продолжить;
			КонецЕсли;
			НоваяСтрока = Объект.БазовыеВидыРасчета.Добавить();
			НоваяСтрока.ВидРасчета = ВремВР;
		КонецЦикла;
	КонецЕсли;
	
	Если ИспользоватьСвойство("ВедущиеВидыРасчета", СписокСвойств, ИсключаяСвойства) Тогда
		Объект.ВедущиеВидыРасчета.Очистить();
		Для Каждого ТекВР Из СтруктураОбъекта.ВедущиеВидыРасчета Цикл
			ВремВР = ЗначениеИзСтруктуры(ТекВР);
			Если НЕ ЗначениеЗаполнено(ВремВР) Тогда
				Продолжить;
			КонецЕсли;
			НоваяСтрока = Объект.ВедущиеВидыРасчета.Добавить();
			НоваяСтрока.ВидРасчета = ВремВР;
		КонецЦикла;
	КонецЕсли;
	
	Если МетаОбъект.ИспользованиеПериодаДействия
	   И ИспользоватьСвойство("ВытесняющиеВидыРасчета", СписокСвойств, ИсключаяСвойства) Тогда
		Объект.ВытесняющиеВидыРасчета.Очистить();
		Для Каждого ТекВР Из СтруктураОбъекта.ВытесняющиеВидыРасчета Цикл
			ВремВР = ЗначениеИзСтруктуры(ТекВР);
			Если НЕ ЗначениеЗаполнено(ВремВР) Тогда
				Продолжить;
			КонецЕсли;
			НоваяСтрока = Объект.ВытесняющиеВидыРасчета.Добавить();
			НоваяСтрока.ВидРасчета = ВремВР;
		КонецЦикла;
	КонецЕсли;
	
	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "ПериодДействияБазовый", СписокСвойств, ИсключаяСвойства);
	
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Код", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаИзСтруктуры(Объект, СтруктураОбъекта, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
КонецПроцедуры //ПланВидовРасчетаИзСтруктуры()

// Преобразует узел обмена в структуру
//
// Параметры:
//  Объект				- Объект, ЛюбаяСсылка		- Преобразуемый объект
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Ссылка			- Структура		- Описание ссылки на объект
//			Тип 						- Строка		- Текстовое описание типа объекта
//			Ид                          - Строка		- Уникальный идентификатор ссылки
//			ИдПолный					- Строка		- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево		- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка		- Имя предопределенного значения
//			Представление				- Строка		- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный	- Дополнительные поля добавленные при выгрузке
//		__ТЧ			- Массив		- Массив табличных частей объекта
//		<имя поля>						- Произвольный	- Значения реквизитов объекта
//
Функция ПланОбменаВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = Объект.Метаданные();
	
	СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект));
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	Если ИспользоватьСвойство("ЭтотУзел", СписокСвойств, ИсключаяСвойства) Тогда
		СтруктураОбъекта.Вставить("ЭтотУзел", ПланыОбмена[МетаОбъект.Имя].ЭтотУзел() = Объект.Ссылка);
	КонецЕсли;
	//СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ЭтотУзел", СписокСвойств, ИсключаяСвойства); Не совместимо со старыми версиями
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "НомерОтправленного", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "НомерПринятого", СписокСвойств, ИсключаяСвойства);
	
	СтруктураОбъекта.Вставить("Код", Неопределено);
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Код", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	СтруктураОбъекта.Вставить("Наименование", Неопределено);
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Возврат СтруктураОбъекта;
	
КонецФункции //ПланОбменаВСтруктуру()

// Заполняет узел плана обмена из структуры
//
// Параметры:
//  Объект				- Объект					- Заполняемый объект
//  СтруктураОбъекта	- Структура					- Данные для заполнения объекта
//		Ссылка					- Структура				- Описание ссылки на объект
//			Тип 						- Строка			- Текстовое описание типа объекта
//			Ид                          - Строка			- Уникальный идентификатор ссылки
//			ИдПолный					- Строка			- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево			- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка			- Имя предопределенного значения
//			Представление				- Строка			- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный		- Дополнительные поля добавленные при выгрузке
//		__ТЧ					- Массив				- Массив табличных частей объекта
//		<имя поля>				- Произвольный			- Значения реквизитов объекта
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ПланОбменаИзСтруктуры(Объект, СтруктураОбъекта, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = Объект.Метаданные();
	
	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	
	Если НЕ Объект.ЭтотУзел Тогда
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "НомерОтправленного", СписокСвойств, ИсключаяСвойства);
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "НомерПринятого", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Код", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаИзСтруктуры(Объект, СтруктураОбъекта, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
КонецПроцедуры //ПланОбменаИзСтруктуры()

// Преобразует документ в структуру
//
// Параметры:
//  Объект				- Объект, ЛюбаяСсылка		- Преобразуемый объект
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Ссылка			- Структура		- Описание ссылки на объект
//			Тип 						- Строка		- Текстовое описание типа объекта
//			Ид                          - Строка		- Уникальный идентификатор ссылки
//			ИдПолный					- Строка		- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево		- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка		- Имя предопределенного значения
//			Представление				- Строка		- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный	- Дополнительные поля добавленные при выгрузке
//		__ТЧ			- Массив		- Массив табличных частей объекта
//		<имя поля>						- Произвольный	- Значения реквизитов объекта
//
Функция ДокументВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = Объект.Метаданные();
	
	СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект));
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Проведен", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Дата", СписокСвойств, ИсключаяСвойства);
	
	СтруктураОбъекта.Вставить("Номер", Неопределено);
	//TODO: Тут еще нужно проверить использование нумератора
	Если МетаОбъект.ДлинаНомера > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Номер", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Если ИспользоватьСвойство("Движения", СписокСвойств, ИсключаяСвойства) Тогда
		СтруктураОбъекта.Вставить("Движения", ДвиженияДокументаВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства));
	КонецЕсли;
	
	Возврат СтруктураОбъекта;
	
КонецФункции //ДокументВСтруктуру()

// Заполняет документ из структуры
//
// Параметры:
//  Объект				- Объект					- Заполняемый объект
//  СтруктураОбъекта	- Структура					- Данные для заполнения объекта
//		Ссылка					- Структура				- Описание ссылки на объект
//			Тип 						- Строка			- Текстовое описание типа объекта
//			Ид                          - Строка			- Уникальный идентификатор ссылки
//			ИдПолный					- Строка			- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево			- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка			- Имя предопределенного значения
//			Представление				- Строка			- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный		- Дополнительные поля добавленные при выгрузке
//		__ТЧ					- Массив				- Массив табличных частей объекта
//		<имя поля>				- Произвольный			- Значения реквизитов объекта
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ДокументИзСтруктуры(Объект, СтруктураОбъекта, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = Объект.Метаданные();
	
	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Проведен", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Дата", СписокСвойств, ИсключаяСвойства);
	
	//TODO: Тут еще нужно проверить использование нумератора
	Если МетаОбъект.ДлинаНомера > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Номер", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаИзСтруктуры(Объект, СтруктураОбъекта, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Если ИспользоватьСвойство("Движения", СписокСвойств, ИсключаяСвойства) И СтруктураОбъекта.Свойство("Движения") Тогда
		ДвиженияДокументаИзСтруктуры(Объект, СтруктураОбъекта.Движения, СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
КонецПроцедуры //ДокументИзСтруктуры()

// Преобразует бизнес-процесс в структуру
//
// Параметры:
//  Объект				- Объект, ЛюбаяСсылка		- Преобразуемый объект
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Ссылка			- Структура		- Описание ссылки на объект
//			Тип 						- Строка		- Текстовое описание типа объекта
//			Ид                          - Строка		- Уникальный идентификатор ссылки
//			ИдПолный					- Строка		- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево		- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка		- Имя предопределенного значения
//			Представление				- Строка		- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный	- Дополнительные поля добавленные при выгрузке
//		__ТЧ			- Массив		- Массив табличных частей объекта
//		<имя поля>						- Произвольный	- Значения реквизитов объекта
//
Функция БизнесПроцессВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = Объект.Метаданные();
	
	СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект));
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Дата", СписокСвойств, ИсключаяСвойства);
	
	СтруктураОбъекта.Вставить("Номер", Неопределено);
	Если МетаОбъект.ДлинаНомера > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Номер", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Стартован", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Завершен", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ВедущаяЗадача", СписокСвойств, ИсключаяСвойства);
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Возврат СтруктураОбъекта;
	
КонецФункции //БизнесПроцессВСтруктуру()

// Заполняет бизнес-процесс из структуры
//
// Параметры:
//  Объект				- Объект					- Заполняемый объект
//  СтруктураОбъекта	- Структура					- Данные для заполнения объекта
//		Ссылка					- Структура				- Описание ссылки на объект
//			Тип 						- Строка			- Текстовое описание типа объекта
//			Ид                          - Строка			- Уникальный идентификатор ссылки
//			ИдПолный					- Строка			- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево			- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка			- Имя предопределенного значения
//			Представление				- Строка			- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный		- Дополнительные поля добавленные при выгрузке
//		__ТЧ					- Массив				- Массив табличных частей объекта
//		<имя поля>				- Произвольный			- Значения реквизитов объекта
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура БизнесПроцессИзСтруктуры(Объект, СтруктураОбъекта, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = Объект.Метаданные();
	
	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Дата", СписокСвойств, ИсключаяСвойства);
	
	Если МетаОбъект.ДлинаНомера > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Номер", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Стартован", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Завершен", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "ВедущаяЗадача", СписокСвойств, ИсключаяСвойства);
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаИзСтруктуры(Объект, СтруктураОбъекта, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
КонецПроцедуры //БизнесПроцессИзСтруктуры()

// Преобразует задачу в структуру
//
// Параметры:
//  Объект				- Объект, ЛюбаяСсылка		- Преобразуемый объект
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Ссылка			- Структура		- Описание ссылки на объект
//			Тип 						- Строка		- Текстовое описание типа объекта
//			Ид                          - Строка		- Уникальный идентификатор ссылки
//			ИдПолный					- Строка		- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево		- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка		- Имя предопределенного значения
//			Представление				- Строка		- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный	- Дополнительные поля добавленные при выгрузке
//		__ТЧ			- Массив		- Массив табличных частей объекта
//		<имя поля>						- Произвольный	- Значения реквизитов объекта
//
Функция ЗадачаВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = Объект.Метаданные();
	
	СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект));
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Дата", СписокСвойств, ИсключаяСвойства);
	
	СтруктураОбъекта.Вставить("Номер", Неопределено);
	Если МетаОбъект.ДлинаНомера > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Номер", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	СтруктураОбъекта.Вставить("Наименование", Неопределено);
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "БизнесПроцесс", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Выполнена", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ТочкаМаршрута", СписокСвойств, ИсключаяСвойства);
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Возврат СтруктураОбъекта;
	
КонецФункции //ЗадачаВСтруктуру()

// Заполняет задачу из структуры
//
// Параметры:
//  Объект				- Объект					- Заполняемый объект
//  СтруктураОбъекта	- Структура					- Данные для заполнения объекта
//		Ссылка					- Структура				- Описание ссылки на объект
//			Тип 						- Строка			- Текстовое описание типа объекта
//			Ид                          - Строка			- Уникальный идентификатор ссылки
//			ИдПолный					- Строка			- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево			- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка			- Имя предопределенного значения
//			Представление				- Строка			- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный		- Дополнительные поля добавленные при выгрузке
//		__ТЧ					- Массив				- Массив табличных частей объекта
//		<имя поля>				- Произвольный			- Значения реквизитов объекта
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ЗадачаИзСтруктуры(Объект, СтруктураОбъекта, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = Объект.Метаданные();
	
	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Дата", СписокСвойств, ИсключаяСвойства);
	
	Если МетаОбъект.ДлинаНомера > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Номер", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "БизнесПроцесс", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "Выполнена", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "ТочкаМаршрута", СписокСвойств, ИсключаяСвойства);
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаИзСтруктуры(Объект, СтруктураОбъекта, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
КонецПроцедуры //ЗадачаИзСтруктуры()

// Преобразует набор записей регистра сведений в структуру
//
// Параметры:
//  НаборЗаписей		- РегистрСведенийНаборЗаписей		- Строковое представление типа регистра (например: РегистрСведений.КурсыВалют)
//  СписокСвойств		- Строка, Массив(Строка)			- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)			- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Отбор			- Структура				- Описание отбора записей регистра
//			<имя поля>		- Произвольный			- Значение отбора
//		Записи			- Массив(Структура)		- Массив записей регистра
//			<имя поля>		- Произвольный			- Значения измерений, ресурсов и реквизитов записи регистра
//
Функция НаборЗаписейРегистраСведенийВСтруктуру(НаборЗаписей, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = НаборЗаписей.Метаданные();
	
	СтруктураОбъекта.Вставить("Отбор", Новый Структура());
	
	Если МетаОбъект.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору Тогда
		СтруктураОбъекта.Отбор.Вставить("Регистратор", ЗначениеВСтруктуру(НаборЗаписей.Отбор.Регистратор.Значение));
	Иначе
		Если НЕ МетаОбъект.ПериодичностьРегистраСведений = Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
			СтруктураОбъекта.Отбор.Вставить("Период", НаборЗаписей.Отбор.Период.Значение);
		КонецЕсли;
		
		Для Каждого ТекЭлемент Из НаборЗаписей.Отбор Цикл
			Если НЕ ИспользоватьСвойство(ТекЭлемент.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураОбъекта.Отбор.Вставить(ТекЭлемент.Имя, ЗначениеВСтруктуру(ТекЭлемент.Значение));
		КонецЦикла;
	КонецЕсли;
	
	МассивСтрок = Новый Массив();
	
	Для Каждого ТекСтрока Из НаборЗаписей Цикл
		
		СтруктураСтроки = Новый Структура();
		
		Если МетаОбъект.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору Тогда
			СтруктураСтроки.Вставить("Регистратор", ЗначениеВСтруктуру(ТекСтрока.Регистратор));
			Если ИспользоватьСвойство("НомерСтроки", СписокСвойств, ИсключаяСвойства) Тогда
				СтруктураСтроки.Вставить("НомерСтроки", ТекСтрока.НомерСтроки);
			КонецЕсли;
			СтруктураСтроки.Вставить("Активность", ТекСтрока.Активность);
		КонецЕсли;
		
		Если НЕ МетаОбъект.ПериодичностьРегистраСведений = Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
			СтруктураСтроки.Вставить("Период", ТекСтрока.Период);
		КонецЕсли;
		
		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;
		
		МассивСтрок.Добавить(СтруктураСтроки);
		
	КонецЦикла;

	СтруктураОбъекта.Вставить("Записи", МассивСтрок);
	
	Возврат СтруктураОбъекта;
	
КонецФункции //НаборЗаписейРегистраСведенийВСтруктуру()

// Заполняет набор записей регистра сведений из структуры
//
// Параметры:
//  НаборЗаписей		- РегистрСведенийНаборЗаписей		- Набор записей регистра для заполнения
//  СтруктураОбъекта	- Структура							- Данные для заполнения объекта
//		Отбор				- Структура							- Описание отбора записей регистра
//			<имя поля>			- Произвольный						- Значение отбора
//		Записи				- Массив(Структура)					- Массив записей регистра
//			<имя поля>			- Произвольный						- Значения измерений, ресурсов и реквизитов записи регистра
//  СписокСвойств		- Строка, Массив(Строка)			- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)			- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура НаборЗаписейРегистраСведенийИзСтруктуры(НаборЗаписей, СтруктураОбъекта, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = НаборЗаписей.Метаданные();
	
	Если МетаОбъект.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору Тогда
		НаборЗаписей.Отбор.Регистратор.Установить(ЗначениеИзСтруктуры(СтруктураОбъекта.Отбор.Регистратор));
	Иначе
		Если НЕ МетаОбъект.ПериодичностьРегистраСведений = Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
			НаборЗаписей.Отбор.Период.Установить(СтруктураОбъекта.Отбор.Период);
		КонецЕсли;
		
		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ (СтруктураОбъекта.Отбор.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НаборЗаписей.Отбор[ТекПоле.Имя].Установить(ЗначениеИзСтруктуры(СтруктураОбъекта.Отбор[ТекПоле.Имя]));
		КонецЦикла;
	КонецЕсли;
		
	НаборЗаписей.Очистить();
	
	Для Каждого ТекЗапись Из СтруктураОбъекта.Записи Цикл
		
		НоваяЗапись = НаборЗаписей.Добавить();
		
		Если МетаОбъект.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору Тогда
			НоваяЗапись.Регистратор = ЗначениеИзСтруктуры(ТекЗапись.Регистратор);
			НоваяЗапись.Активность = ТекЗапись.Активность;
		КонецЕсли;
		
		Если НЕ МетаОбъект.ПериодичностьРегистраСведений = Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
			НоваяЗапись.Период = ТекЗапись.Период;
		КонецЕсли;
		
		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя]);
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя]);
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя]);
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры //НаборЗаписейРегистраСведенийИзСтруктуры()

// Преобразует набор записей регистра накопления в структуру
//
// Параметры:
//  НаборЗаписей		- РегистрСведенийНаборЗаписей		- Строковое представление типа регистра (например: РегистрСведений.КурсыВалют)
//  СписокСвойств		- Строка, Массив(Строка)			- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)			- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Отбор			- Структура				- Описание отбора записей регистра
//			<имя поля>		- Произвольный			- Значение отбора
//		Записи			- Массив(Структура)		- Массив записей регистра
//			<имя поля>		- Произвольный			- Значения измерений, ресурсов и реквизитов записи регистра
//
Функция НаборЗаписейРегистраНакопленияВСтруктуру(НаборЗаписей, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = НаборЗаписей.Метаданные();
	
	СтруктураОбъекта.Вставить("Отбор", Новый Структура());
	
	СтруктураОбъекта.Отбор.Вставить("Регистратор", ЗначениеВСтруктуру(НаборЗаписей.Отбор.Регистратор.Значение));
	
	МассивСтрок = Новый Массив();
	
	Для Каждого ТекСтрока Из НаборЗаписей Цикл
		
		СтруктураСтроки = Новый Структура();
		
		СтруктураСтроки.Вставить("Регистратор", ЗначениеВСтруктуру(ТекСтрока.Регистратор));
		
		Если ИспользоватьСвойство("НомерСтроки", СписокСвойств, ИсключаяСвойства) Тогда
			СтруктураСтроки.Вставить("НомерСтроки", ТекСтрока.НомерСтроки);
		КонецЕсли;
	
		СтруктураСтроки.Вставить("Активность", ТекСтрока.Активность);
		
		Если МетаОбъект.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
			СтруктураСтроки.Вставить("ВидДвижения", ?(ТекСтрока.ВидДвижения = ВидДвиженияНакопления.Приход, "Приход", "Расход"));
		КонецЕсли;
		
		СтруктураСтроки.Вставить("Период", ТекСтрока.Период);
		
		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ТекСтрока[ТекПоле.Имя]);
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;
		
		МассивСтрок.Добавить(СтруктураСтроки);
		
	КонецЦикла;

	СтруктураОбъекта.Вставить("Записи", МассивСтрок);
	
	Возврат СтруктураОбъекта;
	
КонецФункции //НаборЗаписейРегистраНакопленияВСтруктуру()

// Заполняет набор записей регистра накопления из структуры
//
// Параметры:
//  НаборЗаписей		- РегистрСведенийНаборЗаписей		- Набор записей регистра для заполнения
//  СтруктураОбъекта	- Структура							- Данные для заполнения объекта
//		Отбор				- Структура							- Описание отбора записей регистра
//			<имя поля>			- Произвольный						- Значение отбора
//		Записи				- Массив(Структура)					- Массив записей регистра
//			<имя поля>			- Произвольный						- Значения измерений, ресурсов и реквизитов записи регистра
//  СписокСвойств		- Строка, Массив(Строка)			- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)			- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура НаборЗаписейРегистраНакопленияИзСтруктуры(НаборЗаписей, СтруктураОбъекта, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = НаборЗаписей.Метаданные();
	
	НаборЗаписей.Отбор.Регистратор.Установить(ЗначениеИзСтруктуры(СтруктураОбъекта.Отбор.Регистратор));
	
	НаборЗаписей.Очистить();
	
	Для Каждого ТекЗапись Из СтруктураОбъекта.Записи Цикл
		
		НоваяЗапись = НаборЗаписей.Добавить();
		
		НоваяЗапись.Регистратор = ЗначениеИзСтруктуры(ТекЗапись.Регистратор);
		
		НоваяЗапись.Активность = ТекЗапись.Активность;
		
		Если МетаОбъект.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
			НоваяЗапись.ВидДвижения = Вычислить("ВидДвиженияНакопления." + ТекЗапись.ВидДвижения);
		КонецЕсли;
		
		НоваяЗапись.Период = ТекЗапись.Период;
		
		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя]);
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ТекЗапись[ТекПоле.Имя];
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя]);
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры //НаборЗаписейРегистраНакопленияИзСтруктуры()

// Преобразует набор записей регистра бухгалтерии в структуру
//
// Параметры:
//  НаборЗаписей		- РегистрСведенийНаборЗаписей		- Строковое представление типа регистра (например: РегистрСведений.КурсыВалют)
//  СписокСвойств		- Строка, Массив(Строка)			- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)			- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Отбор			- Структура				- Описание отбора записей регистра
//			<имя поля>		- Произвольный			- Значение отбора
//		Записи			- Массив(Структура)		- Массив записей регистра
//			<имя поля>		- Произвольный			- Значения измерений, ресурсов и реквизитов записи регистра
//
Функция НаборЗаписейРегистраБухгалтерииВСтруктуру(НаборЗаписей, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = НаборЗаписей.Метаданные();
	
	СтруктураОбъекта.Вставить("Отбор", Новый Структура());
	
	СтруктураОбъекта.Отбор.Вставить("Регистратор", ЗначениеВСтруктуру(НаборЗаписей.Отбор.Регистратор.Значение));
	
	МассивСтрок = Новый Массив();
	
	Для Каждого ТекСтрока Из НаборЗаписей Цикл
		
		СтруктураСтроки = Новый Структура();
		
		СтруктураСтроки.Вставить("Регистратор", ЗначениеВСтруктуру(ТекСтрока.Регистратор));
		
		Если ИспользоватьСвойство("НомерСтроки", СписокСвойств, ИсключаяСвойства) Тогда
			СтруктураСтроки.Вставить("НомерСтроки", ТекСтрока.НомерСтроки);
		КонецЕсли;
	
		СтруктураСтроки.Вставить("Активность", ТекСтрока.Активность);
		
		СтруктураСтроки.Вставить("Период", ТекСтрока.Период);
		
		Если МетаОбъект.ДлинаУточненияПериода > 0
		   И ИспользоватьСвойство("УточнениеПериода", СписокСвойств, ИсключаяСвойства) Тогда
			СтруктураСтроки.Вставить("УточнениеПериода", ТекСтрока.УточнениеПериода);
		КонецЕсли;
		
		Если МетаОбъект.Корреспонденция Тогда
			СтруктураСтроки.Вставить("СчетДт", ЗначениеВСтруктуру(ТекСтрока.СчетДт));
			СтруктураСтроки.Вставить("СчетКт", ЗначениеВСтруктуру(ТекСтрока.СчетКт));
			
			СтруктураСтроки.Вставить("СубконтоДт", ЗначенияСубконтоЗаписиВСтруктуру(ТекСтрока, "Дт", СписокСвойств, ИсключаяСвойства));
			СтруктураСтроки.Вставить("СубконтоКт", ЗначенияСубконтоЗаписиВСтруктуру(ТекСтрока, "Кт", СписокСвойств, ИсключаяСвойства));
		Иначе
			СтруктураСтроки.Вставить("ВидДвижения", ?(ТекСтрока.ВидДвижения = ВидДвиженияБухгалтерии.Дебет, "Дебет", "Кредит"));
			
			СтруктураСтроки.Вставить("Счет", ЗначениеВСтруктуру(ТекСтрока.Счет));
			
			СтруктураСтроки.Вставить("Субконто", ЗначенияСубконтоЗаписиВСтруктуру(ТекСтрока, "", СписокСвойств, ИсключаяСвойства));
		КонецЕсли;
		
		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			Если МетаОбъект.Корреспонденция И НЕ ТекПоле.Балансовый Тогда
				СтруктураСтроки.Вставить(ТекПоле.Имя + "Дт", ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя + "Дт"]));
				СтруктураСтроки.Вставить(ТекПоле.Имя + "Кт", ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя + "Кт"]));
			Иначе
				СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			Если МетаОбъект.Корреспонденция И НЕ ТекПоле.Балансовый Тогда
				СтруктураСтроки.Вставить(ТекПоле.Имя + "Дт", ТекСтрока[ТекПоле.Имя + "Дт"]);
				СтруктураСтроки.Вставить(ТекПоле.Имя + "Кт", ТекСтрока[ТекПоле.Имя + "Кт"]);
			Иначе
				СтруктураСтроки.Вставить(ТекПоле.Имя, ТекСтрока[ТекПоле.Имя]);
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;
		
		МассивСтрок.Добавить(СтруктураСтроки);
		
	КонецЦикла;

	СтруктураОбъекта.Вставить("Записи", МассивСтрок);
	
	Возврат СтруктураОбъекта;
	
КонецФункции //НаборЗаписейРегистраБухгалтерииВСтруктуру()

// Заполняет набор записей регистра бухгалтерии из структуры
//
// Параметры:
//  НаборЗаписей		- РегистрСведенийНаборЗаписей		- Набор записей регистра для заполнения
//  СтруктураОбъекта	- Структура							- Данные для заполнения объекта
//		Отбор				- Структура							- Описание отбора записей регистра
//			<имя поля>			- Произвольный						- Значение отбора
//		Записи				- Массив(Структура)					- Массив записей регистра
//			<имя поля>			- Произвольный						- Значения измерений, ресурсов и реквизитов записи регистра
//  СписокСвойств		- Строка, Массив(Строка)			- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)			- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура НаборЗаписейРегистраБухгалтерииИзСтруктуры(НаборЗаписей, СтруктураОбъекта, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = НаборЗаписей.Метаданные();
	
	НаборЗаписей.Отбор.Регистратор.Установить(ЗначениеИзСтруктуры(СтруктураОбъекта.Отбор.Регистратор));
	
	НаборЗаписей.Очистить();
	
	Для Каждого ТекЗапись Из СтруктураОбъекта.Записи Цикл
		
		НоваяЗапись = НаборЗаписей.Добавить();
		
		НоваяЗапись.Регистратор = ЗначениеИзСтруктуры(ТекЗапись.Регистратор);
		
		НоваяЗапись.Активность = ТекЗапись.Активность;
		НоваяЗапись.Период = ТекЗапись.Период;
		
		Если МетаОбъект.ДлинаУточненияПериода > 0
		   И ИспользоватьСвойство("УточнениеПериода", СписокСвойств, ИсключаяСвойства) Тогда
			НоваяЗапись.УточнениеПериода = ТекЗапись.УточнениеПериода;
		КонецЕсли;
		
		Если МетаОбъект.Корреспонденция Тогда
			НоваяЗапись.СчетДт = ЗначениеИзСтруктуры(ТекЗапись.СчетДт);
			НоваяЗапись.СчетКт = ЗначениеИзСтруктуры(ТекЗапись.СчетКт);
			
			ЗначенияСубконтоЗаписиИзСтруктуры(НоваяЗапись, ТекЗапись, "Дт", СписокСвойств, ИсключаяСвойства);
			ЗначенияСубконтоЗаписиИзСтруктуры(НоваяЗапись, ТекЗапись, "Кт", СписокСвойств, ИсключаяСвойства);
		Иначе
			НоваяЗапись.ВидДвижения = Вычислить("ВидДвиженияБухгалтерии." + ТекЗапись.ВидДвижения);
			
			НоваяЗапись.Счет = ЗначениеИзСтруктуры(ТекЗапись.Счет);
			
			ЗначенияСубконтоЗаписиИзСтруктуры(НоваяЗапись, ТекЗапись, "", СписокСвойств, ИсключаяСвойства);
		КонецЕсли;
		
		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			Если МетаОбъект.Корреспонденция И НЕ ТекПоле.Балансовый Тогда
				ЗаполнитьИзмерениеРегистраБухгалтерии(НоваяЗапись, ТекЗапись, ТекПоле, "Дт");
				ЗаполнитьИзмерениеРегистраБухгалтерии(НоваяЗапись, ТекЗапись, ТекПоле, "Кт");
			Иначе
				ЗаполнитьИзмерениеРегистраБухгалтерии(НоваяЗапись, ТекЗапись, ТекПоле, "");
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			Если МетаОбъект.Корреспонденция И НЕ ТекПоле.Балансовый Тогда
				НоваяЗапись[ТекПоле.Имя + "Дт"] = ТекЗапись[ТекПоле.Имя + "Дт"];
				НоваяЗапись[ТекПоле.Имя + "Кт"] = ТекЗапись[ТекПоле.Имя + "Кт"];
			Иначе
				НоваяЗапись[ТекПоле.Имя] = ТекЗапись[ТекПоле.Имя];
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя]);
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры //НаборЗаписейРегистраБухгалтерииИзСтруктуры()

// Преобразует набор записей регистра расчета в структуру
//
// Параметры:
//  НаборЗаписей		- РегистрСведенийНаборЗаписей		- Строковое представление типа регистра (например: РегистрСведений.КурсыВалют)
//  СписокСвойств		- Строка, Массив(Строка)			- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)			- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Отбор			- Структура				- Описание отбора записей регистра
//			<имя поля>		- Произвольный			- Значение отбора
//		Записи			- Массив(Структура)		- Массив записей регистра
//			<имя поля>		- Произвольный			- Значения измерений, ресурсов и реквизитов записи регистра
//
Функция НаборЗаписейРегистраРасчетаВСтруктуру(НаборЗаписей, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = НаборЗаписей.Метаданные();
	
	СтруктураОбъекта.Вставить("Отбор", Новый Структура());
	
	СтруктураОбъекта.Отбор.Вставить("Регистратор", ЗначениеВСтруктуру(НаборЗаписей.Отбор.Регистратор.Значение));
	
	Для Каждого ТекЭлемент Из НаборЗаписей.Отбор Цикл
		Если НЕ ИспользоватьСвойство(ТекЭлемент.Имя, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;
		СтруктураОбъекта.Отбор.Вставить(ТекЭлемент.Имя, ЗначениеВСтруктуру(ТекЭлемент.Значение));
	КонецЦикла;
	
	МассивСтрок = Новый Массив();
	
	Для Каждого ТекСтрока Из НаборЗаписей Цикл
		
		СтруктураСтроки = Новый Структура();
		
		СтруктураСтроки.Вставить("Регистратор", ЗначениеВСтруктуру(ТекСтрока.Регистратор));
		
		Если ИспользоватьСвойство("НомерСтроки", СписокСвойств, ИсключаяСвойства) Тогда
			СтруктураСтроки.Вставить("НомерСтроки", ТекСтрока.НомерСтроки);
		КонецЕсли;
	
		СтруктураСтроки.Вставить("Активность"		, ТекСтрока.Активность);
		
		СтруктураСтроки.Вставить("ВидРасчета"		, ЗначениеВСтруктуру(ТекСтрока.ВидРасчета));
		
		СтруктураСтроки.Вставить("Сторно"			, ТекСтрока.Сторно);
		
		СтруктураСтроки.Вставить("ПериодРегистрации", ТекСтрока.ПериодРегистрации);
		
		Если МетаОбъект.БазовыйПериод Тогда
			СтруктураСтроки.Вставить("БазовыйПериодНачало"	, ТекСтрока.БазовыйПериодНачало);
			СтруктураСтроки.Вставить("БазовыйПериодКонец"	, ТекСтрока.БазовыйПериодКонец);
		КонецЕсли;
		
		Если МетаОбъект.ПериодДействия Тогда
			СтруктураСтроки.Вставить("ПериодДействия"		, ТекСтрока.ПериодДействия);
			СтруктураСтроки.Вставить("ПериодДействияНачало"	, ТекСтрока.ПериодДействияНачало);
			СтруктураСтроки.Вставить("ПериодДействияКонец"	, ТекСтрока.ПериодДействияКонец);
			
			МассивПериодов = Новый Массив();
			
			Для Каждого ТекПериод Из ТекСтрока.ФактическийПериодДействия Цикл
				МассивПериодов.Добавить(Новый Структура("ДатаНачала, ДатаОкончания", ТекПериод.ДатаНачала, ТекПериод.ДатаОкончания));
			КонецЦикла;
			СтруктураСтроки.Вставить("ФактическийПериодДействия", МассивПериодов);
		КонецЕсли;
		
		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ТекСтрока[ТекПоле.Имя]);
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;
		
		МассивСтрок.Добавить(СтруктураСтроки);
		
	КонецЦикла;

	СтруктураОбъекта.Вставить("Записи", МассивСтрок);
	
	Возврат СтруктураОбъекта;
	
КонецФункции //НаборЗаписейРегистраРасчетаВСтруктуру()

// Заполняет набор записей регистра расчета из структуры
//
// Параметры:
//  НаборЗаписей		- РегистрСведенийНаборЗаписей		- Набор записей регистра для заполнения
//  СтруктураОбъекта	- Структура							- Данные для заполнения объекта
//		Отбор				- Структура							- Описание отбора записей регистра
//			<имя поля>			- Произвольный						- Значение отбора
//		Записи				- Массив(Структура)					- Массив записей регистра
//			<имя поля>			- Произвольный						- Значения измерений, ресурсов и реквизитов записи регистра
//  СписокСвойств		- Строка, Массив(Строка)			- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)			- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура НаборЗаписейРегистраРасчетаИзСтруктуры(НаборЗаписей, СтруктураОбъекта, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = НаборЗаписей.Метаданные();
	
	НаборЗаписей.Отбор.Регистратор.Установить(ЗначениеИзСтруктуры(СтруктураОбъекта.Отбор.Регистратор));
	
	Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
		Если НЕ (СтруктураОбъекта.Отбор.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
			Продолжить;
		КонецЕсли;
		НаборЗаписей.Отбор[ТекПоле.Имя].Установить(ЗначениеИзСтруктуры(СтруктураОбъекта.Отбор[ТекПоле.Имя]));
	КонецЦикла;
	
	НаборЗаписей.Очистить();
	
	Для Каждого ТекЗапись Из СтруктураОбъекта.Записи Цикл
		
		НоваяЗапись = НаборЗаписей.Добавить();
		
		НоваяЗапись.Регистратор = ЗначениеИзСтруктуры(ТекЗапись.Регистратор);
		
		НоваяЗапись.Активность 			= ТекЗапись.Активность;
		
		НоваяЗапись.ВидРасчета			= ЗначениеИзСтруктуры(ТекЗапись.ВидРасчета);
		
		НоваяЗапись.Сторно				= ТекЗапись.Сторно;
		
		НоваяЗапись.ПериодРегистрации	= ТекЗапись.ПериодРегистрации;
		
		Если МетаОбъект.БазовыйПериод Тогда
			НоваяЗапись.БазовыйПериодНачало	= ТекЗапись.БазовыйПериодНачало;
			НоваяЗапись.БазовыйПериодКонец	= ТекЗапись.БазовыйПериодКонец;
		КонецЕсли;
		
		Если МетаОбъект.ПериодДействия Тогда
			НоваяЗапись.ПериодДействияНачало	= ТекЗапись.ПериодДействияНачало;
			НоваяЗапись.ПериодДействияКонец		= ТекЗапись.ПериодДействияКонец;
		КонецЕсли;
		
		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя]);
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ТекЗапись[ТекПоле.Имя];
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя]);
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры //НаборЗаписейРегистраРасчетаИзСтруктуры()

#КонецОбласти

